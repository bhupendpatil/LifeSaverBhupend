<!--Dokumentation Turtlegrafik-->
<html>
<head>
<style type="text/css">
<!--
.Stil2 {
	font-size: large;
	font-weight: bold;
}
-->
</style>
</head>
<body font face="Arial, Helvetica, sans-serif">



<a href="http://ch/aplu/docs/index_de.html"><img src="gifs/home.png" alt="home" width="25" height="25"></a>
<h2>Dokumentation micro:bit</h2>
<h3>Modul import: from microbit import *</h3>
<strong><font size="+1">Direkte Funktionsaufrufe</font></strong>
<br>
(Realmodus)<br>
<table width="100%"  border="1" cellpadding="4" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="28%" bgcolor="#F0F0F5">Funktion</td>
    <td width="62%" bgcolor="#F0F0F5">Aktion</td>
  </tr>
  
  <tr>
    <td>panic(n)</td>
    <td >blockiert das System und zeigt endlos ein &quot;Trauriggesicht&quot; gefolgt von n (f&uuml;r Entwickler)</td>
  </tr>
   <tr>
    <td>reset()</td>
    <td >startet das System neu (f&uuml;hrt main.py aus)</td>
  </tr>
   <tr>
     <td>sleep(dt)</td>
     <td >h&auml;lt das Programm w&auml;hrend dt Millisekunden an</td>
   </tr>
   <tr>
     <td>running_time()</td>
     <td >gibt die Zeit in Millisekunden zur&uuml;ck, seit das Board eingeschaltet oder resetted wurde</td>
   </tr>
   <tr>
     <td>temperature()</td>
     <td >gibt die Temperatur in Grad Celsius zur&uuml;ck (als Float)</td>
   </tr>  
</table>
<br>
<br>
<hr>
<br>
<font size="+1"><strong>Klasse Button</strong></font><br>
(Real- und Simulationsmodus)
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td>button_a</td>
    <td >Objektreferenz (Instanz) des Buttons A</td>
  </tr>
  <tr>
    <td width="28%">button_b</td>
    <td width="62%">Objektreferenz (Instanz) des Buttons B</td>
  </tr>
</table>
<strong><br>
Methoden:</strong>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td>is_pressed()</td>
    <td >gibt True zur&uuml;ck, falls der Button beim Aufruf gedr&uuml;ckt ist; andernfalls False</td>
  </tr>
  <tr>
    <td width="28%">was_pressed()</td>
    <td width="62%">gibt True zur&uuml;ck, falls der Button seit dem letzten Aufruf (oder dem Start des Programms) gedr&uuml;ckt wurde. Ein erneuter Aufruf gibt False zur&uuml;ck, bis der Button wieder gedruckt wird</td>
  </tr>
  <tr>
    <td>get_presses()</td>
    <td>gibt die Anzahl Tastenbet&auml;tigungen seit dem letzten Aufruf (oder dem Start des Programms) zur&uuml;ck. Ein erneuter Aufruf gibt 0 zur&uuml;ck, bis die Taste wieder bet&auml;tigt wird</td>
  </tr>
</table>
<p><br>
        <strong>Beispiel: </strong><br>
        <font face="Courier New, Courier, monospace">if button_a.was_pressed():</font><br>
        <font face="Courier New, Courier, monospace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mache_etwas</font></p>
<p><strong>Bemerkung: </strong><br>
    Im Simulationsmodus dr&uuml;ckt man einen Button mit der linken Maustaste. Bet&auml;tigt man die rechte Maustaste, so wird der Button im gedr&uuml;ckten Zustand gehalten, bis man wieder mit einer Maustaste dr&uuml;ckt. Damit kann man das gleichzeitige Dr&uuml;cken der Tasten simulieren.     <br>
</p>
<hr>
<br>
<strong><font size="+1">Klasse Display</font> </strong><br>
(Real- und Simulationsmodus)<br>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="28%">display</td>
    <td width="62%" >Objektreferenz (Instanz)</td>
  </tr>
</table>
<br>
<strong>Methoden:</strong>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
    <tr>
        <td>set_pixel(x, y, value)</td>
        <td >setzt die Intensit&auml;t des Pixels an der Position x, y. value ist im Bereich 0..9</td>
    </tr>
    <tr>
      <td>get_pixel(x, y)</td>
      <td >liefert den Wert des Pixels an der Position x, y</td>
    </tr>
  <tr>
      <td>clear()</td>
      <td >l&ouml;scht alle Pixels</td>
  </tr>
  <tr>
    <td>show(str)</td>
    <td >schreibt str auf dem LED-Display aus. Enth&auml;lt dieser mehrere Zeichen, so werden diese in Laufschrift angezeigt, die auf dem letzten Zeichen stehen bleibt </td>
  </tr>
  <tr>
    <td>show(list_of_img, delay = 400,  loop = False, wait = True, clear = False)</td>
    <td>zeigt alle Images der Liste nacheinander an. Falls loop = True ist, wird die Anzeigesequenz endlos wiederholt. F&uuml;r wait = True ist die Methode blockierend, andernfalls kehrt sie zur&uuml;ck und die Anzeige erfolge im Hintergrund. delay ist die Anzeigezeit pro Bild in Millisekunden (default: 400). F&uuml;r clear = True wird die Anzeige nach dem letzten Bild gel&ouml;scht</td>
  </tr>
  <tr>
    <td width="28%">show(img)</td>
    <td width="62%">zeigt das img auf dem LED-Display. Ist img gr&ouml;sser als 5x5 pixels, so wird der Bereich x, y = 0..4 angezeigt. Ist img kleiner als 5x5 pixels, sind die fehlenden Pixels ausgeschaltet</td>
  </tr>
  <tr>
    <td>scroll(str)</td>
    <td>zeigt str als Laufschrift. Das letzte Zeichen verschwindet (blockierende Methode)</td>
  </tr>
  <tr>
    <td>scroll(str, delay = 150,  loop = False, wait = True, monospace = False)</td>
    <td>zeigt str als Laufschrift.  Falls loop = True ist, wird die Anzeigesequenz endlos wiederholt. F&uuml;r wait = True ist die Methode blockierend, andernfalls kehrt sie zur&uuml;ck und die Anzeige erfolge im Hintergrund. delay ist die Anzeigezeit pro Spalte  in Millisekunden (default: 150)</td>
  </tr>
</table>
<strong><br>
Beispiele: </strong><br>
<font face="Courier New, Courier, monospace">display.show(&quot;A&quot;)</font><br>
<font face="Courier New, Courier, monospace">display.scroll(&quot;Hallo&quot;)</font><font face="Courier New, Courier, monospace"><br>
display.show([Image.HAPPY, Image.SAD])</font><br>
<br>
<br>
<hr>
<br>
<font size="+1"><strong>Klasse Image</strong> </font><br>
(Real- und Simulationsmodus)<br>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td>Image(str)</td>
    <td ><p>erzeugt eine Objektreferenz (Instanz). str hat das Format &quot;aaaaa:bbbbb:ccccc:ddddd:eeeee:&quot;, wo a eine Zahl im Bereich 0..9 ist, welche die Intensit&auml;t des Pixels angibt. a sind die Werte f&uuml;r die erste Zeile, b f&uuml;r die zweite, usw.</p>    </td>
  </tr>
  <tr>
    <td width="28%">Image()</td>
    <td width="62%">erzeugt eine Objektreferenz (Instanz) mit 5x5 ausgeschalteten Pixels</td>
  </tr>
  <tr>
    <td>Image(width, height)</td>
    <td>erzeugt eine Objektreferenz (Instanz) mit der gegebenen Zahl horizontaler und vertikaler Pixel, die alle ausgeschaltet sind (value = 0)</td>
  </tr>
</table>
<br>
<strong>Methoden:</strong>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td>set_pixel(x, y, value)</td>
    <td >setzt die Intensit&auml;t des Pixels an der Position x, y. value ist im Bereich 0..9</td>
  </tr>
  <tr>
      <td>fill(value)</td>
      <td>setzt die Intensit&auml;t aller Pixels auf den gleichen Wert (value = 0..9) </td>
  </tr>
  <tr>
      <td>get_pixel(x, y)</td>
      <td>gibt die Intensit&auml;t des Pixels an der Position x, y</td>
  </tr>
  <tr>
    <td width="28%">shift_left(n)</td>
    <td width="62%">gibt ein Image-Objekt zur&uuml;ck, das um n Spalten nach links verschoben ist (rechts eingeschobene Spalten sind ausgeschaltet)</td>
  </tr>
  <tr>
    <td>shift_right(n)</td>
    <td>gibt ein Image-Objekt zur&uuml;ck, das um n Spalten nach rechts verschoben ist (links eingeschobene Spalten sind ausgeschaltet)</td>
  </tr>
  <tr>
    <td>shift_up(n)</td>
    <td>gibt ein Image-Objekt zur&uuml;ck, das um n Zeilen nach oben verschoben ist (unten eingeschobene Spalten sind ausgeschaltet)</td>
  </tr>
  <tr>
    <td>shift_down(n)</td>
    <td>gibt ein Image-Objekt zur&uuml;ck, das um n Zeilen nach unten verschoben ist (oben eingeschobene Spalten sind ausgeschaltet)</td>
  </tr>
  <tr>
    <td>copy()</td>
    <td>gibt einen Klone des Image zur&uuml;ck</td>
  </tr>
  <tr>
    <td>invert()</td>
    <td>gibt ein Image-Objekt mit invertieren Pixels zur&uuml;ck (new_value = 9 - value)</td>
  </tr>
  <tr>
      <td>crop(x, y, w, h)</td>
      <td>gibt einen Bildausschnitt der Breite w und H&ouml;he h zur&uuml;ck. Die obere linke Ecke entspricht dem Pixel x, y des Originalbildes</td>
  </tr>
  <tr>
      <td>dest.blit(img, x, y, w, h, xdest, ydest)</td>
      <td>kopiert vom gegebenen img einen rechteckigen Bereich an der Position x, y mit Breite w und H&ouml;he h in das Image dest an der Stelle xdest, ydest</td>
  </tr>
</table>
<strong><br>
Operationen:</strong>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td>image_new = image * n</td>
    <td >gibt ein Image-Objekt zur&uuml;ck, bei dem alle Pixel-Intensit&auml;ten mit dem Faktor n multipliziert sind</td>
  </tr>
  <tr>
    <td width="28%">image_new = image1 + image2</td>
    <td width="62%">gibt ein Image-Objekt zur&uuml;ck, bei dem die Intensit&auml;ten der Pixel von image1 und image2 addiert wurden</td>
  </tr>
</table>
<strong><br>
</strong>
<p><strong><br>
  Vordefinierte Objekte:</strong></p>
<ul>
  <li><font size="-1">Image.HEART</font></li>
  <li><font size="-1">Image.HEART_SMALL</font></li>
  <li><font size="-1">Image.HAPPY</font></li>
  <li><font size="-1">Image.SMILE</font></li>
  <li><font size="-1">Image.SAD</font></li>
  <li><font size="-1">Image.CONFUSED</font></li>
  <li><font size="-1">Image.ANGRY</font></li>
  <li><font size="-1">Image.ASLEEP</font></li>
  <li><font size="-1">Image.SURPRISED</font></li>
  <li><font size="-1">Image.SILLY</font></li>
  <li><font size="-1">Image.FABULOUS</font></li>
  <li><font size="-1">Image.MEH</font></li>
  <li><font size="-1">Image.YES</font></li>
  <li><font size="-1">Image.NO</font></li>
  <li><font size="-1">Image.CLOCK12, Image.CLOCK11, Image.CLOCK10, Image.CLOCK9,  Image.CLOCK8, Image.CLOCK7, Image.CLOCK6, Image.CLOCK5,  Image.CLOCK4, Image.CLOCK3, Image.CLOCK2, Image.CLOCK1</font></li>
  <li><font size="-1">Image.ARROW_N, Image.ARROW_NE, Image.ARROW_E,  Image.ARROW_SE, Image.ARROW_S, Image.ARROW_SW,  Image.ARROW_W, Image.ARROW_NW</font></li>
  <li><font size="-1">Image.TRIANGLE</font></li>
  <li><font size="-1">Image.TRIANGLE_LEFT</font></li>
  <li><font size="-1">Image.CHESSBOARD</font></li>
  <li><font size="-1">Image.DIAMOND</font></li>
  <li><font size="-1">Image.DIAMOND_SMALL</font></li>
  <li><font size="-1">Image.SQUARE</font></li>
  <li><font size="-1">Image.SQUARE_SMALL</font></li>
  <li><font size="-1">Image.RABBIT</font></li>
  <li><font size="-1">Image.COW</font></li>
  <li><font size="-1">Image.MUSIC_CROTCHET</font></li>
  <li><font size="-1">Image.MUSIC_QUAVER</font></li>
  <li><font size="-1">Image.MUSIC_QUAVERS</font></li>
  <li><font size="-1">Image.PITCHFORK</font></li>
  <li><font size="-1">Image.XMAS</font></li>
  <li><font size="-1">Image.PACMAN</font></li>
  <li><font size="-1">Image.TARGET</font></li>
  <li><font size="-1">Image.TSHIRT</font></li>
  <li><font size="-1">Image.ROLLERSKATE</font></li>
  <li><font size="-1">Image.DUCK</font></li>
  <li><font size="-1">Image.HOUSE</font></li>
  <li><font size="-1">Image.TORTOISE</font></li>
  <li><font size="-1">Image.BUTTERFLY</font></li>
  <li><font size="-1">Image.STICKFIGURE</font></li>
  <li><font size="-1">Image.GHOST</font></li>
  <li><font size="-1">Image.SWORD</font></li>
  <li><font size="-1">Image.GIRAFFE</font></li>
  <li><font size="-1">Image.SKULL</font></li>
  <li><font size="-1">Image.UMBRELLA</font></li>
  <li><font size="-1">Image.SNAKE</font></li>
  <li><font size="-1"> Listen:
    Image.ALL_CLOCKS,  Image.ALL_ARROWS</font></li>
</ul>
<blockquote><div></div>
</blockquote>
<p><strong>Bemerkung: </strong><br>
Ein Image-Objekt (kurz ein &quot;Image&quot;) ist eine Abstraktion eines realen Pixelbildes und wird erst sichtbar, wenn <font face="Courier New, Courier, monospace">display.show(img)</font> aufgerufen wird. Das Image kann eine beliebige Zahl horizontaler und vertikaler Pixels (w, h) haben, aber es werden mit <font face="Courier New, Courier, monospace">show(img)</font> nur die Pixels im Bereich x = 0..4, y = 0..4 angezeigt. (Ist das Image kleiner, so sind die nicht definierten Pixels dunkel.)</p>
<p>Man beachte, dass einige Methoden nicht das Bild selbst modifizieren, sondern ein modifiziertes Bild zur&uuml;ckgeben. Um  <font face="Courier New, Courier, monospace">img</font> zu &auml;ndern, kann man ihm das neue Bild zuweisen.</p>
<p><strong></strong><br>
    <strong>Beispiele: </strong><br>
    <font face="Courier New, Courier, monospace">img = Image(2, 2)<br>
  img = img.invert()<br>
  display.show(img)<br>
    </font><span class="Stil2"><br>
    </span></p>
<hr>
<br>
<font size="+1"><strong>Klasse MicroBitTouchPin</strong> </font><br>
(Real- und Simulationsmodus nur *)<br>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td>pin0, pin1, pin2, pin8, pin12, pin16</td>
    <td >Instanzen f&uuml;r allgemeines Digital-in/Digital-out</td>
  </tr>
  <tr>
    <td width="28%">pin0, pin1, pin2</td>
    <td width="62%">Instanzen f&uuml;r  Analog-in/Analog-out (PWM)</td>
  </tr>
  <tr>
    <td>pin3, pin4, pin6, pin7, pin9, pin10</td>
    <td>Instanzen vordefiniert f&uuml;r LED display (display mode)</td>
  </tr>
  <tr>
    <td>pin5, pin11</td>
    <td>Instanzen vordefiniert f&uuml;r  Button A, B (button mode)</td>
  </tr>
  <tr>
    <td>pin13, pin14, pin15</td>
    <td>Instanzen vordefiniert f&uuml;r   SPI (spi mode)</td>
  </tr>
  <tr>
    <td>pin19, pin20</td>
    <td>Instanzen vordefiniert f&uuml;r I2C (i2c mode)</td>
  </tr>
</table>
<br>
<strong>Methoden:</strong>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td>*read_digital()</td>
    <td >gibt 1 zur&uuml;ck, falls Pin auf logisch 1 (HIGH) ist; gibt 0 zur&uuml;ck, falls Pin auf logisch 0 (LOW) ist (Pulldown 10 kOhm)</td>
  </tr>
  <tr>
    <td width="28%">*write_digital(v)</td>
    <td width="62%">falls  v = 1, wird der Pin auf logisch 1 (HIGH) gesetzt; fals v = 0, wird der Pin auf logisch 0 (LOW) gesetzt (max. Strom: 5 mA)</td>
  </tr>
  <tr>
    <td>read_analog()</td>
    <td>gibt Wert des ADC im Bereich  0..1023 zur&uuml;ck (Eingangsimpedanz:  10&nbsp;MOhm)</td>
  </tr>
  <tr>
    <td>write_analog(v)</td>
    <td>setzt den PWM Duty Cycle (v = 0..1023 entsprechend 0..100%) (max. Strom: 5&nbsp;mA)</td>
  </tr>
  <tr>
    <td>set_analog_period(period)</td>
    <td>setzt die PWM-Periode in Millisekunden</td>
  </tr>
  <tr>
    <td>set_analog_period_microseconds(period)</td>
    <td>setzt die PWM-Periode in Mikrosekunden (&gt; 300)</td>
  </tr>
</table>
<br>
<br>
<hr>
  <font size="+1"><strong><br>
  Klasse Accelerometer</strong></font>  
  <br>
  (Real- und Simulationsmodus)<br>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="28%">accelerometer</td>
    <td width="62%" >Objektreferenz (Instanz)</td>
  </tr>
</table>
<br>
<strong>Methoden:</strong>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td>get_x(), get_y(), get_z()</td>
    <td >gibt die Beschleunigung in  x-, y- oder z-Richtung zur&uuml;ck (int,   Bereich ca. -2047 bis +2048, entsprechend ungef&auml;hr -20 m/s^2 bis +20 m/s^2, die Erdbeschleunigung von ungef&auml;hr 10 m/s^2 wird mitgez&auml;hlt). x-Richtung: ButtonA-ButtonB; y-Richtung: Pin2-USB; z-Richtung: Normale zum Board</td>
  </tr>
  <tr>
    <td width="28%">get_values()</td>
    <td width="62%">gibt ein Tupel mit den Beschleunigungen in   x-, y- oder z-Richtung zur&uuml;ck (Einheit wie oben)</td>
  </tr>
  <tr>
    <td>current_gesture()</td>
    <td><p>gibt die aktuelle Geste zur&uuml;ck. Folgende Gesten werden erkannt: &quot; up&quot;, &quot; down&quot;, &quot; left&quot;, &quot; right&quot;, &quot; face up&quot;, 
&quot; face down&quot;, &quot; freefall&quot;, &quot; 3g&quot;, &quot; 6g&quot;, &quot; 8g&quot;, &quot; shake&quot;</p>
    </td>
  </tr>
  <tr>
    <td>is_gesture(name)</td>
    <td>gibt True zur&uuml;ck, falls die aktuelle Geste gleich name ist</td>
  </tr>
  <tr>
    <td>get_gestures()</td>
    <td>gibt eine Tupel mit den zuletzt gemachten Gesten zur&uuml;ck. Die letzte Geste ist am Ende des Tupels. L&ouml;scht zudem die Gestenhistorie</td>
  </tr>
  <tr>
    <td>was_gesture(name)</td>
    <td>gibt True zur&uuml;ck, falls sich name in der Gestenhistorie befindet</td>
  </tr>
</table>
<br>
<br>
<hr>
<br>
<strong><font size="+1">Klasse Compass</font></strong><br>
(nur Realmodus)<br>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="28%">compass</td>
    <td width="62%" >Objektreferenz (Instanz)</td>
  </tr>
</table>
<br>
<strong>Methods:</strong>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td>calibrate()</td>
    <td >startet eine blockierende Kalibrierungsroutine, die f&uuml;r genaue Messungen n&ouml;tig ist. Man muss den micro:bit in verschiedenen Richtungen schief stellen, so dass der blinkende Punkt die  Randpixel erreicht und diese anz&uuml;ndet. Erst wenn eine Kreisfigur erstellt ist, f&auml;hrt das Programm weiter</td>
  </tr>
  <tr>
    <td width="28%">is_calibrated()</td>
    <td width="62%">gibt True zur&uuml;ck, falls der Sensor kalibriert wurde</td>
  </tr>
  <tr>
    <td>clear_calibration()</td>
    <td>setzt den Sensor auf den nicht-kalibrierten Zustand zur&uuml;ck</td>
  </tr>
  <tr>
    <td>heading()</td>
    <td>gibt den aktuellen Winkel des micro:bit zur Nordrichtung (Grad, int)</td>
  </tr>
  <tr>
    <td>get_x(), get_y(), get_z()</td>
    <td>gibt den aktuellen Wert der x, y oder z-Komponente des Magnetfeldes an der Stelle des Sensors zur&uuml;ck (int, Mikrotesla, keine Kalibrierung n&ouml;tig)</td>
  </tr>
  <tr>
    <td>get_values()</td>
    <td>gibt ein Tupel der    x-, y- und z-Komponenten des Magnetfeldes an der Stelle des Sensors zur&uuml;ck (int,  Mikrotesla, keine Kalibrierung n&ouml;tig)</td>
  </tr>
</table>
<br>
<br>
<hr>
<br>
  <strong><font size="+1">Klasse NeoPixel</font></strong>
  <font size="-1"><br>
  </font>(nur Realmodus)<font size="-1"><br>
  (<strong>Modul import: from neopixel import *</strong>)</font>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="28%">np = NeoPixel(pin, n)</td>
    <td width="62%" ><p>erzeugt eine Neopixel Objekt (Instanz) mit n Neopixels, die an den gegebenen Pin angeschlossen sind. Jeder Pixel wird durch seine Position adressiert (beginnend bei 0) und seine Farbe wird durch eine Zuweisung eines RGB-Tubels bestimmt, z.B.  np[2] = (0, 100, 255) setzt Pixel # 2 auf Rot = 0, Gr&uuml;n = 100, Blue = 255. <em>show()</em> muss aufgerufen werden, damit die &Auml;nderung sichbar wird.</p>
        <p>(Strips mit WS2812 LEDs unterst&uuml;tzt.)</p></td>
  </tr>
</table>
<br>
<strong>Methods:</strong>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td>clear()</td>
    <td ><p>l&ouml;scht  alle Pixels</p></td>
  </tr>
  <tr>
    <td width="28%">show()</td>
    <td width="62%">zeigt die Pixels an. Muss bei jeder &Auml;nderung der Farbwerte aufgerufen werden, damit diese sichbar ist</td>
  </tr>
</table>
<br>
<br>
<hr>
<p></p>
<p><strong><font size="+1">Modul music</font></strong> <br>
    (nur Realmodus)<br>
  <font size="-1"> (<strong>Modul import: from music import *</strong>)</font><br>
  <br>
</p>
<strong>Funktionen:</strong>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td>set_tempo(bpm = 120)</td>
    <td >setzt die Anzahl  Beats pro Minute (default: 120)</td>
  </tr>
  <tr>
    <td width="28%">pitch(frequency, len, pin = microbit.pin0, wait = True)</td>
    <td width="62%">spielt einen Ton mit gegebener Frequenz in Hertz w&auml;hrend der gegebenen Zeit in Millisekunden.  pin definiert den Output-Pin am GPIO-Stecker (default: P0). Falls wait = True, ist die Funktion blockierend; sonst kehrt sie zur&uuml;ck, w&auml;hrend der Ton weiter spielt (bis die Abspieldauer erreicht ist oder  stop() aufgerufen wird)</td>
  </tr>
  <tr>
    <td>play(melody, pin = microbit.pin0, wait = True, loop = False)</td>
    <td>spielt eine Melodie mit dem aktuellen Tempo.). pin definiert den Output-Pin am GPIO-Stecker (default: P0). Falls wait = True, ist die Funktion blockierend; sonst kehrt sie zur&uuml;ck, w&auml;hrend die Melodie weiter spielt (bis die Abspieldauer erreicht ist oder  stop() aufgerufen wird). Falls  loop = True, wird die Melodie endlos erneut abgespielt</td>
  </tr>
  <tr>
    <td>stop(pin = microbit.pin0)</td>
    <td>stoppt alle Sound-Ausgaben am gegebenen GPIO-Pin (default: P0)</td>
  </tr>
</table>
<p><strong>Bemerkungen:</strong> <br>
  Eine Melodie ist eine Liste mit Strings in folgendem Format:  [&quot;note:dauer&quot;, &quot;note:dauer&quot;,...]<br>
  note in musikalischer Notation: c, d, e, f, g, a, h mit optionaler Octavezahl (default: 1): z.B.. c2, d2, ... und optionalem Versetzungszeichen (Halbtonkreuz): c#, d#,... oder c#2, d#2,...<br>
  dauer in Anzahl Ticks (optional, defaut: 1)</p>
<p><strong>Vordefinierte Melodien:</strong></p>
<ul>
  <li><font size="-1">ADADADUM - Er&ouml;ffnung von  Beethoven&rsquo;s 5. Sinfonie in C Moll</font></li>
  <li><font size="-1">ENTERTAINER - Er&ouml;ffnungsfragment von Scott Joplin&rsquo;s Ragtime Klassiker &ldquo;The Entertainer&rdquo;</font></li>
  <li><font size="-1">PRELUDE -Er&ouml;ffnung des ersten Prelude in C Dur von J.S.Bach&rsquo;s 48 Preludien und Fugen</font></li>
  <li><font size="-1">ODE - &ldquo;Ode an Joy&rdquo; Thema aus  Beethoven&rsquo;s 9. Sinfonie in D Moll</font></li>
  <li><font size="-1">NYAN - das Nyan Cat Thema</font></li>
  <li><font size="-1">RINGTONE - ein Klingelton</font></li>
  <li><font size="-1">FUNK - ein Ger&auml;usch f&uuml;r Geheimagenten </font></li>
  <li><font size="-1">BLUES - ein Boogie-Woogie Blues</font></li>
  <li><font size="-1">BIRTHDAY - &ldquo;Happy Birthday to You...&rdquo;</font></li>
  <li><font size="-1">WEDDING - der Chorus des Br&auml;utigams aus Wagner&rsquo;s Oper &ldquo;Lohengrin&rdquo;</font></li>
  <li><font size="-1">FUNERAL - der &ldquo;Trauerzug&rdquo;, auch bekannt als Fr&eacute;d&eacute;ric Chopin&rsquo;s Klaviersonate No. 2 in B&#9837;Moll</font></li>
  <li><font size="-1">PUNCHLINE - a lustiger Tonclip, nachdem ein Witz gemacht wurde</font></li>
  <li><font size="-1">PYTHON   - John Philip Sousa&rsquo;s Marsch &ldquo;Liberty Bell&rdquo;, ein Thema aus &ldquo;Monty   Python&rsquo;s Flying Circus&rdquo;</font></li>
  <li><font size="-1">BADDY - Filmclip aus &quot;The Baddy</font>&quot;</li>
  <li><font size="-1">CHASE - Filmclick aus einer Jagdszene</font></li>
  <li><font size="-1">BA_DING - ein Signalton, der darauf hinweist, dass etwas geschehen ist</font></li>
  <li><font size="-1">WAWAWAWAA - ein trauriger Posaunenklang</font></li>
  <li><font size="-1">JUMP_UP - f&uuml;r Spiele, um auf eine Aufw&auml;rtsbewegung hinzuweisen</font></li>
  <li><font size="-1">JUMP_DOWN - f&uuml;r Spiele, um auf eine Abw&auml;rtsbewegung hinzuweisen</font></li>
  <li><font size="-1">POWER_UP - ein Fanfarenklang, der darauf hinweist, dass etwas erreicht wurde</font></li>
  <li><font size="-1">POWER_DOWN - ein trauriger Fanfarenklang, der darauf hinweist, dass etwas verloren gegangen ist</font><br>
    <br>
  </li>
</ul>
<hr>
<br>
<p><strong><font size="+1">Modul radio:</font></strong><br>
    (nur Realmodus)<br>
    <font size="-1">(<strong>Modul import: from radio import *</strong>)</font><br>
  <font size="-1"><br>
  </font>Computerkommunikation &uuml;ber Bluetooth</p>
<strong>Funktionen:</strong>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td>on()</td>
    <td >schaltet die Bluetooth-Kommunikation ein. Verbindet mit einem micro:bit mit eingeschaltetem Bluetooth</td>
  </tr>
  <tr>
    <td width="24%">off()</td>
    <td width="76%">schaltet die Bluetooth-Kommunikation aus</td>
  </tr>
  <tr>
    <td>send(msg)</td>
    <td>sendet eine String-Message in den Messagebuffer des Empf&auml;ngerknotens  (First-In-First-Out, FIFO-Buffer)</td>
  </tr>
  <tr>
    <td>msg = receive()</td>
    <td><p>gibt die &auml;lteste Message  (string) des Messagebuffers zur&uuml;ck und entfernt sie aus dem Buffer. Falls der Buffer leer ist, wird None zur&uuml;ckgegeben. Es wird vorausgesetzt, dass  die Messages mit send(msg) gesendet wurden, damit sie sich in Strings umwandeln lassen [sonst wird eine ValueError Exception (&quot;received packet is not a string&quot;) geworfen]</p>
    </td>
  </tr>
  <tr>
    <td>send_bytes(msg_bytes)</td>
    <td>sendet eine Message als Bytes (Klasse <em>bytes, e.g b'\x01</em>\x48') in den Messagebuffer des Empf&auml;ngerknotens (First-In-First-Out, FIFO-Buffer) </td>
  </tr>
  <tr>
    <td>receive_bytes()</td>
    <td><p>gibt die &auml;lteste Message (bytes) des  Messagebuffers zur&uuml;ck und entfernt sie aus dem Buffer. Falls der Buffer leer ist, wird None zur&uuml;ckgegeben. Zum Senden muss send_bytes(msg) verwendet werden (und nicht send(msg))</p>
    </td>
  </tr>
</table>
<br>
<br>
<br>
<hr>
<br>
<p>&nbsp;</p>
<p><strong><font size="+1">Modul mbglow</font></strong><br>
    (Real- und Simulationsmodus)<br>
    <font size="-1">(<strong>Modul import: from mbglow import *</strong>)</font><br>
</p>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
    <tr>
        <td width="28%">
            <p>makeGlow()</p>          
        </td>
      <td width="62%" >erzeugt einen sichtbaren Leuchtk&auml;fer mit Position (0, 0), Richtung Norden, Spur sichtbar. Koordinatensystem: -2 &lt;=x &lt;=2 (+ nach rechts), -2 &lt;= y &lt;= 2 (+ nach oben). (0, 0) auf mittlerem Pixel</td>
  </tr>
    <tr>
      <td>setSpeed()</td>
      <td>setzt die Geschwindigkeit f&uuml;r die Bewegungen (0..100)</td>
    </tr>
    <tr>
        <td>show()</td>
        <td>macht den Leuchtk&auml;fer an der aktuellen Position und f&uuml;r die n&auml;chsten Bewegungen sichtbar</td>
    </tr>
    <tr>
        <td>hide()</td>
        <td>macht den Leuchtk&auml;fer f&uuml;r die n&auml;chsten Bewegungen unsichtbar</td>
    </tr>
    <tr>
      <td>clear()</td>
      <td>l&ouml;scht alle eingeschalteten Pixels. Der Leuchtk&auml;fer bleibt an der aktuellen Position (unsichtbar)</td>
    </tr>
    <tr>
        <td>showTrace(enable)</td>
        <td>macht die Spur f&uuml;r die n&auml;chsten Bewegungen (Pixel an besuchten Stellen) sichtbar/unsichtbar</td>
    </tr>
    <tr>
        <td>forward()</td>
        <td>bewegt den Leuchtk&auml;fer um einen Schritt vorw&auml;rts</td>
    </tr>
    <tr>
        <td>back()</td>
        <td>bewegt den Leuchtk&auml;fer um einen Schritt r&uuml;ckw&auml;rts</td>
    </tr>
    <tr>
        <td>left(angle)</td>
        <td>dreht die Bewegungsrichtung um 45 Grad-Schritte nach links (angle = 45, 90, 135, 180, 215, 270, 315)</td>
    </tr>
    <tr>
        <td>right(angle)</td>
        <td>dreht die Bewegungsrichtung um 45 Grad-Schritte nach rechts (angle = 45, 90, 135, 180, 225, 270, 315)</td>
    </tr>
    <tr>
        <td>setPos(x, y)</td>
        <td>setzt den Leuchtk&auml;fer auf Position (x, y)</td>
    </tr>
    <tr>
        <td>getPos()</td>
        <td>gibt die aktuelle Position des Leuchtk&auml;fers als Tupel zur&uuml;ck</td>
    </tr>
    <tr>
        <td>isLit()</td>
        <td>gibt True zur&uuml;ck, falls das Pixel an der Stelle des Leuchtk&auml;fers eingeschaltet ist</td>
    </tr>
</table>
<strong><br>
</strong><strong></strong>
<p><br>
</p>
<h4><a href="http://ch/aplu/docs/index_de.html"><br>
<img src="gifs/home.png" alt="home" width="25" height="25"></a></h4>
<p>&nbsp;</p>
<p>&nbsp;</p>
</body>
</html>