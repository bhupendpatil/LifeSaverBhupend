<html>
<head>
</head>
<body font face="Arial, Helvetica, sans-serif">
<h2><a href="http://ch/aplu/docs/index_en.html"><img src="gifs/home.png" alt="home" width="25" height="25"></a></h2>
<h2>Documentation Raspberry Pi GPIO (RPi_GPIO)</h2>
<p>&nbsp;</p>
<h4>General</h4>
<p>The General Purpose Input Output system of the Raspberry Pi uses 17 data lines (Rev.B board: 26) that can be configured individually as digital input  or digital output using 3.3V logic levels.There are two ways of numbering the IO
 pins on a Raspberry Pi within raspi.GPIO. The first and default mode is using the BOARD numbering system. This refers to the pin numbers 1..26 (Rev.B board: 1..40) on the P1 header of the Raspberry Pi board. The second uses the LINE numbering system where pins are numbered in a line sequence on one the side of the header followed by the pins on the other side.<font face="Courier New, Courier, monospace"></font>
<table width="752" border="0">
  <tr>
    <td width="89">&nbsp;</td>
    <td width="653"><img src="gifs/GPIOPins.png" alt="GPIOPins" width="664" height="401"></td>
  </tr>
</table>
<font face="Courier New, Courier, monospace"><br>
</font> An effort was made to reflect as close as possible the well-known Python <a href="https://pypi.python.org/pypi/RPi.GPIO">RPi.GPIO</a> module. The underlying implementation uses the Pi4J Java library. As consequence the class design is somewhat &quot;pythonic&quot; .
<p><strong>You must run the program as root user (with supervisor rights) because it needs access to the GPIO system.</strong></p>
<h3>Module import:  from RPi_GPIO import GPIO </h3>
<h4>Class GPIO:</h4>

<table width="100%"  border="1" cellpadding="3" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="22%" bgcolor="#F0F0F5">Method</td>
    <td width="78%" bgcolor="#F0F0F5">Action</td>
  </tr>
  <tr>
    <td> GPIO.BOARD</td>
    <td>
      <p>Constant for setmode(): Channel numbering using header pin numbers(default). Value: 0<br>
      </p>
    </td>
  </tr>
  <tr>
    <td>GPIO.LINE</td>
    <td>Constant  for setmode(): Channel numbering in rows for 26 pin header. Value: 1</td>
  </tr>
  <tr>
    <td>GPIO.LINE40</td>
    <td>Constant  for setmode(): Channel numbering in rows for 40 pin header. Value: 2</td>
  </tr>
  <tr>
    <td>GPIO.OUT</td>
    <td>Constant for setup(): Output channel. Value: 0</td>
  </tr>
  <tr>
    <td>GPIO.IN</td>
    <td>Constant for setup(): Input channel. Value: 1</td>
  </tr>
  <tr>
    <td>GPIO.LOW</td>
    <td>Logic level low, corresponds to 0 V. Value: 0</td>
  </tr>
  <tr>
    <td>GPIO.HIGH</td>
    <td>Logic level high, corresponds to 3.3 V. Value: 1</td>
  </tr>
  <tr>
    <td>GPIO.PUD_DOWN</td>
    <td>Constant for setup(): Internal pull-down resistor. Value: 2</td>
  </tr>
  <tr>
    <td>GPIO.PUD_UP</td>
    <td>Constant for setup(): Internal pull-up resistor. Value: 3</td>
  </tr>
  <tr>
    <td>GPIO.PUD_NONE</td>
    <td>Constant for setup(): No internal pull-up/down resistor (floating). Value: 4</td>
  </tr>
  <tr>
    <td>GPIO.RISING</td>
    <td>Constant for add_event_detect(): Trigger event on rising edge</td>
  </tr>
  <tr>
    <td>GPIO.FALLING</td>
    <td>Constant for add_event_detect(): Trigger event on falling edge</td>
  </tr>
  <tr>
    <td>GPIO.BOTH</td>
    <td>Constant for add_event_detect(): Trigger event on both edges</td>
  </tr>
  <tr>
    <td>GPIO.setmode(mode)</td>
    <td>selects channel numbering mode: BOARD or LINE</td>
  </tr>
  <tr>
    <td>GPIO.setup(channel, ioControl, option)</td>
    <td>selects the channel as input or output. Output: option HIGH/LOW sets initial value; Input: option PUD_UP, PUD_DOWN, PUD_NONE selects internal pull-up/down resistor</td>
  </tr>
  <tr>
    <td>GPIO.cleanup()</td>
    <td>releases all resources and restores the default values</td>
  </tr>
  <tr>
    <td>GPIO.out(channel, state)</td>
    <td>sets the logical level of an output channel</td>
  </tr>
  <tr>
    <td>GPIO.input(channel)</td>
    <td>returns the state of an input channel (or the last setting  of an output channel)</td>
  </tr>
  <tr>
    <td>GPIO.add_event_detect(channel, trigger)</td>
    <td>prepares the channel to get trigger events and selects the edge detection (RISING, FALLING, BOTH)</td>
  </tr>
  <tr>
    <td>GPIO.add_event_callback(channel, callback, bounceTime)</td>
    <td>registers a callback function for the given channel. After an event the trigger is inactive during the given bounceTime (in ms). The callback has the following signature <em>callback(channel, state) </em>with the current channel and its state</td>
  </tr>
  <tr>
    <td>GPIO.add_event_callback(channel, callback)</td>
    <td>same with bounceTime = 0</td>
  </tr>
  <tr>
    <td>GPIO.wait_for_edge(channel, trigger)</td>
    <td>waits infinitely for a trigger event as defined in  add_event_detect()</td>
  </tr>
  <tr>
    <td>GPIO.wait_for_edge(channel, trigger, timeout)</td>
    <td>waits the maximum timeout  (in ms) for a trigger event. Returns 0, if a trigger occured; otherwise returns -1</td>
  </tr>
  <tr>
    <td>GPIO.event_detected(channel)</td>
    <td>returns True if a trigger occured since the last invocation (the channel must be prepared with   add_event_detect())</td>
  </tr>
  <tr>
    <td>GPIO.getVersion()</td>
    <td>returns the current version of the library module</td>
  </tr>
  <tr>
    <td>p = GPIO.PWM(channel, freq, duty)</td>
    <td>creates and starts a pulse-width-modulation generator with given. frequency (1..500 Hz) and given duty cycle (0...100 %). Returns a PWM reference</td>
  </tr>
  <tr>
    <td>p = GPIO.PWM(channel, freq)</td>
    <td>creates  a pulse-width-modulation generator with given frequency (1..500 Hz), but does not start it (duty = 0). Returns a PWM reference</td>
  </tr>
  <tr>
    <td>p.start(duty)</td>
    <td>starts or modifies the PWM with given duty cycle (0..100 %)</td>
  </tr>
  <tr>
    <td>p.changeDutyCycle(duty)</td>
    <td>starts or modifies the PWM with given duty cycle (0..100 %)</td>
  </tr>
  <tr>
    <td>p.stop()</td>
    <td>stops the PWM (sets duty = 0)</td>
  </tr>
  <tr>
    <td>GPIO.delay(ms)</td>
    <td>stops the process for the given time (in ms)</td>
  </tr>
</table>
<h4></h4>
<h4><a href="http://ch/aplu/docs/index_en.html"><img src="gifs/home.png" alt="home" width="25" height="25"></a></h4>
<p>&nbsp;</p>
</body>
</html>

