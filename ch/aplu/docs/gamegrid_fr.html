<html>
<head>
</head>
<body font face="Arial, Helvetica, sans-serif">
<a href="http://ch/aplu/docs/index_fr.html"><img src="gifs/home.png" alt="home" width="25" height="25"></a>
<h2>M&eacute;thodes principales de la classe JGameGrid </h2 >
<p><strong>Importation du module: from gamegrid </strong><strong>import * </strong></p>
<strong>Classe GameGrid </strong>(fonctions globales  lorsque la grille est construite avec <em>makeGameGrid()</em>)
<table width="100%"  border="1" bordercolor="#CCCCCC" cellspacing="0" cellpadding="3">
  <tr>
    <td width="37%" bgcolor="#F0F0F5">M&eacute;thode</td>
    <td width="63%" bgcolor="#F0F0F5">Action</td>
  </tr>
  <tr>
    <td width="37%">GameGrid(nbHorzCells, nbVertCells, cellSize, color)</td>
    <td width="63%">G&eacute;n&egrave;re  une fen&ecirc;tre de jeu poss&eacute;dant le nombre indiqu&eacute; de cellules en horizontal et en  vertical. Elles ont une taille de <em>cellSize</em>.  Les lignes de la grille sont visibles et de couleur <em>color</em></td>
  </tr>
  <tr>
    <td> GameGrid(nbHorzCells, nbVertCells, cellSize, color, bgImagePath)</td>
    <td>Idem,  en utilisant l&rsquo;image de fond <em>bgImagePath</em></td>
  </tr>
  <tr>
    <td> GameGrid(nbHorzCells, nbVertCells, cellSize, None, bgImagePath, False)</td>
    <td>Idem,  sans afficher les lignes de la grille (<em>color=None</em>)  ni la barre de navigation (<em>False</em>)</td>
  </tr>
  <tr>
    <td> act()</td>
    <td>M&eacute;thode  appel&eacute;e par le syst&egrave;me &agrave; chaque cycle de simulation apr&egrave;s les Actor.act()
      <div>
          <div> </div>
      </div>
    </td>
  </tr>
  <tr>
    <td> addActor(actor, location)</td>
    <td>Ajoute  l&rsquo;acteur <em>actor </em>&agrave; la fen&ecirc;tre de jeu &agrave;  la position indiqu&eacute;e</td>
  </tr>
  <tr>
    <td> addKeyListener(listener)</td>
    <td>Enregistre  la fonction de rappel <em>listener </em>pour  g&eacute;rer les &eacute;v&eacute;nements clavier</td>
  </tr>
  <tr>
    <td> addMouseListener(listener, mouseEventMask)</td>
    <td>Enregistre  la fonction de rappel <em>listener </em>pour  g&eacute;rer les &eacute;v&eacute;nements souris</td>
  </tr>
  <tr>
    <td> addStatusBar(height)</td>
    <td>Ajoute  une barre d&rsquo;&eacute;tat &agrave; la fen&ecirc;tre de jeu</td>
  </tr>
  <tr>
    <td> delay(time)</td>
    <td>Met le  programme en pause pendant <em>time </em>millisecondes</td>
  </tr>
  <tr>
    <td> doPause()</td>
    <td>Met  les cycles de simulation en pause</td>
  </tr>
  <tr>
    <td> doStep()</td>
    <td>Effectue  la simulation pas &agrave; pas</td>
  </tr>
  <tr>
    <td> doReset()</td>
    <td>Remet  tous les acteurs &agrave; leur position initiale et red&eacute;marre la simulation</td>
  </tr>
  <tr>
    <td> doRun()</td>
    <td>D&eacute;marre  les cycles de simulation</td>
  </tr>
  <tr>
    <td height="27"   >getActors(Actor class)</td>
    <td>Retourne  sous forme de liste tous les acteurs du jeu appartenant &agrave; la classe sp&eacute;cifi&eacute;e</td>
  </tr>
  <tr>
    <td> getBg()</td>
    <td>Retourne  la r&eacute;f&eacute;rence &agrave; <em>GGBackground</em></td>
  </tr>
  <tr>
    <td> getBgColor()</td>
    <td>Retourne  la couleur d&rsquo;arri&egrave;re-fond</td>
  </tr>
  <tr>
    <td> getKeyCode()</td>
    <td>Retourne  le code clavier de la derni&egrave;re touche actionn&eacute;e</td>
  </tr>
  <tr>
    <td> getOneActorAt(location)</td>
    <td>Retourne  le premier acteur de la cellule indiqu&eacute;e par <em>location </em>(z&eacute;ro s&rsquo;il n&rsquo;y a pas d&rsquo;acteur)</td>
  </tr>
  <tr>
    <td> getOneActor(Actor class)</td>
    <td>Retourne  le premier acteur de la classe <em>class </em>(z&eacute;ro  s&rsquo;il n&rsquo;y a pas d&rsquo;acteur de la classe <em>class</em>)</td>
  </tr>
  <tr>
    <td> getRandomEmptyLocation()</td>
    <td width="63%"   >Retourne  la position d&rsquo;une cellule vide choisie au hasard dans la grille de jeu</td>
  </tr>
  <tr>
    <td> getRandomLocation()</td>
    <td>Retourne  la position d&rsquo;une cellule vide ou occup&eacute;e choisie au hasard dans la grille de  jeu</td>
  </tr>
  <tr>
    <td> hide()</td>
    <td>Cache  la fen&ecirc;tre de jeu sans la fermer</td>
  </tr>
  <tr>
    <td> isAtBorder(location)</td>
    <td>Retourne <em>True</em> si la cellule <em>location </em>est situ&eacute;e au bord de la grille  de jeu</td>
  </tr>
  <tr>
    <td> isEmpty(location)</td>
    <td>Retourne <em>True</em> si la cellule <em>location</em> est vide</td>
  </tr>
  <tr>
    <td> isInGrid(location)</td>
    <td>Retourne <em>True</em> si la cellule est situ&eacute;e &agrave;  l&rsquo;int&eacute;rieur de la grille de jeu</td>
  </tr>
  <tr>
    <td> kbhit()</td>
    <td>Retourne <em>True </em>si une touche a &eacute;t&eacute; enfonc&eacute;e</td>
  </tr>
  <tr>
    <td> toLocation(x, y)</td>
    <td>Retourne  la cellule contenant le point de coordonn&eacute;es <em>x</em> et <em>y</em> (pixels) </td>
  </tr>
  <tr>
    <td> openSoundPlayer("wav/ping.wav")</td>
    <td>Pr&eacute;pare  la restitution d&rsquo;un fichier audio. Les sons suivants sont disponibles dans <em>tigerjython.jar</em>: bird.wav,  boing.wav, cat.wav, click.wav, explore.wav, frog.wav, notify.wav
      <div>
          <div> </div>
      </div>
    </td>
  </tr>
  <tr>
    <td> play()</td>
    <td>Joue  le son pr&eacute;c&eacute;demment charg&eacute; avec <em>openSoundPlayer</em></td>
  </tr>
  <tr>
    <td> refresh()</td>
    <td>Rafra&icirc;chit  la fen&ecirc;tre de jeu</td>
  </tr>
  <tr>
    <td> registerAct(onAct)</td>
    <td>Enregistre  la fonction de rappel <em>onAct</em> qui est  appel&eacute;e &agrave; chaque cycle de simulation</td>
  </tr>
  <tr>
    <td> registerNavigation(started = onStart, stepped = onStep, paused = onPause, resetted = onReset, periodChanged = onPeriodChange)</td>
    <td>
      <p>Enregistre  les fonctions de rappel <em>onStart</em>, <em>onStep</em>, <em>onPause</em>, <em>onReset</em>, <em>onPeriodChange </em>qui sont appel&eacute;es lorsque  la barre de navigation est visible. Il n&rsquo;est pas n&eacute;cessaire de toutes les  sp&eacute;cifier. </p>
    </td>
  </tr>
  <tr>
    <td> removeActor (actor)</td>
    <td>Supprime  l&rsquo;acteur <em>actor </em>de la fen&ecirc;tre de jeu</td>
  </tr>
  <tr>
    <td> removeActorsAt(location)&nbsp;</td>
    <td>Supprime  tous les acteurs situ&eacute;s dans la cellule <em>location</em></td>
  </tr>
  <tr>
    <td> removeAllActors()</td>
    <td  >Supprime  tous les acteurs pr&eacute;sents dans la fen&ecirc;tre de jeu</td>
  </tr>
  <tr>
    <td> reset()</td>
    <td>R&eacute;initialise  la simulation en repla&ccedil;ant les acteurs encore pr&eacute;sents sur le jeu &agrave; position qu&rsquo;ils  occupaient avant le d&eacute;but de la partie</td>
  </tr>
  <tr>
    <td> show()</td>
    <td>Afficher  la fen&ecirc;tre de jeu</td>
  </tr>
  <tr>
    <td> setBgColor(color)</td>
    <td>R&egrave;gle la  couleur d&rsquo;arri&egrave;re-plan de la fen&ecirc;tre de jeu</td>
  </tr>
  <tr>
    <td> setSimulationPeriod (milisec)</td>
    <td>R&egrave;gle  la p&eacute;riode de la boucle de simulation</td>
  </tr>
  <tr>
    <td> setStatusText(text)</td>
    <td>Modifie  le texte <em>text </em>de la barre d&rsquo;&eacute;tat</td>
  </tr>
  <tr>
    <td> setTitle(text)</td>
    <td>Ajuste  le titre affich&eacute; dans la barre de titre de la fen&ecirc;tre</td>
  </tr>
</table>
<b> <br>
class Actor</b>
<table width="100%"  border="1" bordercolor="#CCCCCC" cellspacing="0" cellpadding="3">
  <tr>
    <td width="37%"   >Actor(spritepath)</td>
    <td  >G&eacute;n&egrave;re  un acteur associ&eacute; &agrave; l&rsquo;image de sprite charg&eacute;e &agrave; partir du fichier de chemin <em>spritepath</em></td>
  </tr>
  <tr>
    <td> Actor(True, spritepath)</td>
    <td  >Idem. <em>True </em>indique que l&rsquo;acteur peut subir des  rotations</td>
  </tr>
  <tr>
    <td> Actor(spritepath, nbSprites)</td>
    <td  >
      <p>G&eacute;n&egrave;re un acteur avec <em>nbSprites </em>images de sprite diff&eacute;rentes. Les noms de fichiers images seront compos&eacute;s &agrave;  partir des <em>sprite&shy;path </em>en ajoutant un  nombre entre <em>0</em> et <em>nbSprites-1</em> <br>
        Exemple&nbsp;: index_0, index_1, ou fish_0.gif ,  fish_1.gif, &hellip;</p>
    </td>
  </tr>
  <tr>
    <td> Actor(True, spritepath, nbSprites)</td>
    <td  >Idem,  mais en permettant les rotations</td>
  </tr>
  <tr>
    <td> act()</td>
    <td  >M&eacute;thode  appel&eacute;e p&eacute;riodiquement sur chaque acteur apr&egrave;s le d&eacute;but du cycle de simulation</td>
  </tr>
  <tr>
    <td> addActorCollisionListener(listener)</td>
    <td  >Enregistre  le gestionnaire d&rsquo;&eacute;v&eacute;nements de collisions</td>
  </tr>
  <tr>
    <td> addCollisionActor(actor)</td>
    <td  >Enregistre <em>actor </em>comme partenaire de collision</td>
  </tr>
  <tr>
    <td> addMouseTouchListener (listener)</td>
    <td  >Enregistre  le gestionnaire (fonction de rappel) pour l&rsquo;&eacute;v&eacute;nement <em>MouseTouch</em></td>
  </tr>
  <tr>
    <td> collide(actor1, actor2)</td>
    <td  >Fonction  de rappel appel&eacute;e lors d&rsquo;une collision entre <em>actor1 </em>et <em>actor2</em>. Retourne le  nombre de cycles &agrave; partir de la collision pendant lesquels les &eacute;v&eacute;nements de  collision entre <em>actor1</em>et <em>actor2 </em>sont ignor&eacute;s
      <div>
          <div> </div>
      </div>
    </td>
  </tr>
  <tr>
    <td>
      <p>getCollisionActors()</p>
    </td>
    <td>Retourne  une liste de candidats &agrave; la collision</td>
  </tr>
  <tr>
    <td> getDirection()</td>
    <td  >Retourne  la direction du mouvement de l&rsquo;acteur</td>
  </tr>
  <tr>
    <td> getIdVisible()</td>
    <td>Retourne  l&rsquo;ID du sprite actuellement affich&eacute;</td>
  </tr>
  <tr>
    <td> getNeighbours(distance)</td>
    <td>Retourne  une liste de tous les acteurs qui sont &eacute;loign&eacute;s de <em>distance</em> par rapport &agrave; l&rsquo;acteur sur lequel la m&eacute;thode est invoqu&eacute;e. Distance d&eacute;finie un cercle autour du centre de la cellule actuelle (unit&eacute;: largeur de la cellule)</td>
  </tr>
  <tr>
    <td> getNextMoveLocation (location)</td>
    <td width="63%"  >Pr&eacute;dit  les coordonn&eacute;es de l&rsquo;acteur apr&egrave;s le prochain appel &agrave; <em>move()</em></td>
  </tr>
  <tr>
    <td> getX()</td>
    <td  >Retourne  la coordonn&eacute;e horizontale (dans le syst&egrave;me de coordonn&eacute;es grille) de la cellule  occup&eacute;e par l&rsquo;acteur</td>
  </tr>
  <tr>
    <td> getY()</td>
    <td  >Retourne  la coordonn&eacute;e verticale (dans le syst&egrave;me de coordonn&eacute;es grille) de la cellule  occup&eacute;e par l&rsquo;acteur</td>
  </tr>
  <tr>
    <td> hide()</td>
    <td>Cache  l&rsquo;acteur sans le supprimer. Apr&egrave;s <em>reset() </em>il redevient visible</td>
  </tr>
  <tr>
    <td> isInGrid()</td>
    <td  >Retourne <em>True</em> si l&rsquo;acteur est situ&eacute; &agrave;  l&rsquo;int&eacute;rieur de la grille de jeu</td>
  </tr>
  <tr>
    <td> isHorzMirror()</td>
    <td>Retourne <em>True</em> si le sprite de l&rsquo;acteur est  retourn&eacute; horizontalement (inversion gauche-droite)</td>
  </tr>
  <tr>
    <td> isVertMirror()</td>
    <td>Retourne <em>True</em> si le sprite de l&rsquo;acteur est  retourn&eacute; verticalement (inversion haut-bas)</td>
  </tr>
  <tr>
    <td> isMoveValid()</td>
    <td  >Retourne <em>True</em> si l&rsquo;acteur reste dans la  grille de jeu apr&egrave;s un appel &agrave; <em>move()</em></td>
  </tr>
  <tr>
    <td> isNearBorder()</td>
    <td  >Retourne <em>True</em> si l&rsquo;acteur se situe au bord  de la grille de jeu</td>
  </tr>
  <tr>
    <td> isVisible()</td>
    <td>Returns <em>True</em> si l&rsquo;acteur est visible</td>
  </tr>
  <tr>
    <td> move()</td>
    <td  >D&eacute;place  l&rsquo;acteur dans une cellule adjacente en conservant la direction actuelle</td>
  </tr>
  <tr>
    <td> move(distance)</td>
    <td  >Idem,  en sp&eacute;cifiant la distance parcourue par le d&eacute;placement</td>
  </tr>
  <tr>
    <td>
      <p>reset()</p>
    </td>
    <td>M&eacute;thode  appel&eacute;e lorsque l&rsquo;acteur est ajout&eacute; &agrave; la <em>GameGrid</em> et lorsque le bouton &laquo;&nbsp;reset&nbsp;&raquo; est actionn&eacute;</td>
  </tr>
  <tr>
    <td> setCollisionCircle (spriteId,center, radius)</td>
    <td>D&eacute;finit  une zone de collision circulaire de centre <em>center</em> et de rayon <em>radius </em>pour le sprite  d&rsquo;ID <em>spriteId</em></td>
  </tr>
  <tr>
    <td> setCollisionLine(spriteId,                   startPoint,                   endPoint)</td>
    <td>D&eacute;finit  une zone de collision rectiligne d&eacute;finie par les points <em>startPoint</em> et <em>endPoint</em> pour le sprite d&rsquo;ID <em>spriteId</em></td>
  </tr>
  <tr>
    <td> setCollisionRectangle(spriteId, center, width, height)</td>
    <td>D&eacute;finit  une zone de collision rectangulaire de centre <em>center</em>, de largeur <em>width </em>et  de hauteur <em>height</em></td>
  </tr>
  <tr>
    <td> setCollisionSpot(spriteId,                   spot)</td>
    <td>D&eacute;finit  une zone de collision en un unique point de coordonn&eacute;es <em>spot</em> pour le sprite d&rsquo;ID <em>spriteId</em></td>
  </tr>
  <tr>
    <td valign="top" >setCollisionImage(spriteId)</td>
    <td valign="top" >D&eacute;finit les  pixels non-transparents pour la collision. Seulement disponible si le partner utilise spot, line ou circle</td>
  </tr>
  <tr>
    <td> setHorzMirror(True)</td>
    <td>Effectue  une inversion gauche/droite sur le sprite de l&rsquo;acteur</td>
  </tr>
  <tr>
    <td> setVertMirror(True)</td>
    <td>Effectue  une inversion haut/bas sur le sprite de l&rsquo;acteur</td>
  </tr>
  <tr>
    <td> setSlowDown(factor) </td>
    <td  >Ralentit  d&rsquo;un facteur <em>factor</em> les appels &agrave; la  m&eacute;thode <em>act()</em> des acteurs</td>
  </tr>
  <tr>
    <td> setLocation(location)</td>
    <td  >Place  l&rsquo;acteur dans la cellule de coordonn&eacute;es <em>location </em>au sein de la grille de jeu</td>
  </tr>
  <tr>
    <td> setLocationOffset(point)</td>
    <td  >D&eacute;cale  le centre de l&rsquo;image de sprite par rapport au centre de la cellule occup&eacute;e par  l&rsquo;acteur. Ne change rien &agrave; la position de l&rsquo;acteur dans la grille de jeu</td>
  </tr>
  <tr>
    <td> setPixelLocation(location)</td>
    <td  >Place  l&rsquo;acteur aux coordonn&eacute;es <em>location</em> exprim&eacute;es en pixels (la position dans la grille et le d&eacute;calage sont ajust&eacute;s en  cons&eacute;quence)</td>
  </tr
   >
  <tr>
    <td> setX(x)</td>
    <td>Ajuste  la coordonn&eacute;e <em>x</em> &agrave; la valeur sp&eacute;cifi&eacute;e</td>
  </tr>
  <tr>
    <td> setY(y)</td>
    <td>Ajuste  la coordonn&eacute;e <em>y</em> &agrave; la valeur sp&eacute;cifi&eacute;e</td>
  </tr>
  <tr>
    <td> show()</td>
    <td  >Rend  visible le sprite d&rsquo;ID 0</td>
  </tr>
  <tr>
    <td> show(spriteId)</td>
    <td>Rend  visible le sprite d&rsquo;ID <em>spriteId</em></td>
  </tr>
  <tr>
    <td> showNextSprite ()</td>
    <td>Rend  visible la prochaine image de sprite (<em>spriteId </em>est incr&eacute;ment&eacute; de 1 modulo <em>nbSprites</em>).  Ainsi, une fois que l&rsquo;on a atteint le dernier sprite, on recommence au sprite  d&rsquo;id 0</td>
  </tr>
  <tr>
    <td> showPreviousSprite()</td>
    <td>Rend  visible la pr&eacute;c&eacute;dente image de sprite (<em>spriteId </em>est d&eacute;cr&eacute;ment&eacute; de 1 modulo <em>nbSprites</em>).  Ainsi, une fois que l&rsquo;on a atteint le premier sprite d&rsquo;ID 0, en recommence avec  le dernier d&rsquo;ID <em>nbSprite-1</em></td>
  </tr>
  <tr>
    <td> removeSelf()</td>
    <td>Supprime  l&rsquo;acteur. Il ne r&eacute;appara&icirc;t plus lors d&rsquo;un prochain <em>reset()</em></td>
  </tr>
  <tr>
    <td> reset()</td>
    <td> Cette fonction est appel&eacute;e par <em>GameGrid.addActor()</em> et lors d&rsquo;un clic  sur le bouton reset </td>
  </tr>
  <tr>
    <td> turn(angle) </td>
    <td  >Change  la direction du mouvement de l&rsquo;acteur de l&rsquo;angle indiqu&eacute; en degr&eacute;s, dans le  sens des aiguilles de la montre</td>
  </tr>
</table>
<b> <br>
class Location</b>
<table width="100%"  border="1" bordercolor="#CCCCCC" cellspacing="0" cellpadding="3">
  <tr>
    <td   width="37%" >Location(x, y)</td>
    <td>G&eacute;n&egrave;re  un objet <em>location</em> permettant une  localisation &agrave; partir des coordonn&eacute;es horizontales et verticales de la cellule  au sein de la grille de jeux</td>
  </tr>
  <tr>
    <td> Location(location)</td>
    <td>G&eacute;n&egrave;re  un objet <em>location</em> &agrave; partir de <em>location </em>(clone)</td>
  </tr>
  <tr>
    <td> clone()</td>
    <td  >Retourne  une nouvelle localisation avec les m&ecirc;mes coordonn&eacute;es grille</td>
  </tr>
  <tr>
    <td> equals(location)</td>
    <td>Retourne <em>True</em> si la localisation actuelle de  l&rsquo;acteur correspond &agrave; <em>location</em></td>
  </tr>
  <tr>
    <td> get4CompassDirectionTo(location)</td>
    <td>Retourne  une liste comportant les positions des quatre cellules adjacentes Ouest, Est,  Nord, Sud par rapport &agrave; la position courante</td>
  </tr>
  <tr>
    <td> getCompassDirectionTo(location)</td>
    <td>Retourne  une liste comportant les positions des huit cellules adjacentes, &eacute;galement en  diagonale. Donc idem, mais en rajoutant encore Nord-Ouest, Nord-Est, Sud-Est et  Sud-Ouest</td>
  </tr>
  <tr>
    <td> getDirectionTo(location)</td>
    <td>Retourne  en degr&eacute;s la direction &agrave; prendre pour aller de la position actuelle vers la  position <em>location</em> donn&eacute;e. 0 degr&eacute;s =  Est<br />
    </td>
  </tr>
  <tr>
    <td> getNeighbourLocation(direction)</td>
    <td>Retourne  la position d&rsquo;une des huit cellules voisines. C&rsquo;est la cellule la plus proche  de la direction indiqu&eacute;e qui est retourn&eacute;e</td>
  </tr>
  <tr>
    <td> getNeighbourLocations(distance)</td>
    <td>Retourne  une liste de toutes les cellules dont le centre se trouve &agrave; une distance  inf&eacute;rieure ou &eacute;gale &agrave; <em>distance</em> de la  cellule actuelle</td>
  </tr>
  <tr>
    <td> getX()</td>
    <td>Retourne  la position horizontale de la cellule occup&eacute;e par l&rsquo;acteur sur lequel <em>getX()</em> est invoqu&eacute;e</td>
  </tr>
  <tr>
    <td> getY()</td>
    <td>Retourne  la position verticale de la cellule occup&eacute;e par l&rsquo;acteur sur lequel <em>getY()</em> est invoqu&eacute;e</td>
  </tr>
</table>
<b><br>
class GGBackground</b>
<table width="100%"  border="1" bordercolor="#CCCCCC" cellspacing="0" cellpadding="3">
  <tr>
    <td   width="37%">clear()</td>
    <td  >Efface  l&rsquo;arri&egrave;re-fond actuel en rempla&ccedil;ant tous ses pixels par la couleur  d&rsquo;arri&egrave;re-plan actuellement en usage</td>
  </tr>
  <tr>
    <td> clear(color) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
    <td  >Idem,  mais en rempla&ccedil;ant par la couleur d&rsquo;arri&egrave;re-plan <em>color</em></td>
  </tr>
  <tr>
    <td> drawCircle(center, radius)</td>
    <td  >Dessine  un cercle de centre <em>center</em> et de  rayon <em>radius</em>. Les coordonn&eacute;es du  centre ainsi que le rayon sont indiqu&eacute;es en pixels</td>
  </tr>
  <tr>
    <td> drawLine(x1,y1,&nbsp;x2, y2)</td>
    <td  >Dessine  un segment droit entre les points d&eacute;finis par les coordonn&eacute;es pixel (x1, y1) et  (x2, y2).</td>
  </tr>
  <tr>
    <td> drawLine(pt1,&nbsp;pt2)</td>
    <td  >Idem,  mais en donnant les coordonn&eacute;es des points extr&eacute;maux sous forme d&rsquo;objets <em>Point</em> (pixels)</td>
  </tr>
  <tr>
    <td> drawPoint(pt) </td>
    <td  >Dessine  un point de coordonn&eacute;es indiqu&eacute;es par l&rsquo;objet <em>Point pt</em> (pixels)</td>
  </tr>
  <tr>
    <td> drawRectangle(pt1,                pt2)</td>
    <td  >Dessine  un rectangle de sommets sup&eacute;rieur gauche <em>pt1 </em>et inf&eacute;rieur droit <em>pt2</em> (objets <em>Point </em>en pixels)</td>
  </tr>
  <tr>
    <td> drawText(text, pt) </td>
    <td  >&Eacute;crit  le texte <em>text </em>&agrave; la position indiqu&eacute;e  par <em>pt </em>(objet <em>Point</em> en pixels)</td>
  </tr>
  <tr>
    <td> fillCell(location,           color)</td>
    <td  >Remplit  la cellule de position <em>location </em>(coordonn&eacute;es  grille) avec la couleur <em>color</em></td>
  </tr>
  <tr>
    <td> fillCircle(center,radius)</td>
    <td  >Dessine  un cercle plein de centre <em>center </em>et  de rayon <em>radius</em>. Les coordonn&eacute;es et  le rayon sont donn&eacute;s en pixels</td>
  </tr>
  <tr>
    <td> getBgColor() </td>
    <td  >Retourne  la couleur de fond actuelle</td>
  </tr>
  <tr>
    <td> getColor(location)</td>
    <td  >Retourne  la couleur de fond pr&eacute;sente au centre de la cellule <em>location</em>. Les pixels de l&rsquo;acteur ne sont pas pris en compte</td>
  </tr>
  <tr>
    <td> save()</td>
    <td  >Sauvegarde  la couleur de fond actuelle qui peut ensuite &ecirc;tre restitu&eacute;e avec <em>restore()</em>
        <div>
          <div> </div>
        </div>
    </td>
  </tr>
  <tr>
    <td> setBgColor(color)</td>
    <td  >Change  la couleur d&rsquo;arri&egrave;re-fond</td>
  </tr>
  <tr>
    <td> setFont(font)</td>
    <td  >R&egrave;gle  la police de caract&egrave;res utilis&eacute;e pour afficher les textes</td>
  </tr>
  <tr>
    <td> setLineWidth(width)</td>
    <td  >R&egrave;gle  la largeur des lignes</td>
  </tr>
  <tr>
    <td> setPaintColor(color)</td>
    <td  >R&egrave;gle  la couleur de dessin &agrave; <em>color</em></td>
  </tr>
  <tr>
    <td> setPaintMode() </td>
    <td  >
      <p>Dessine  sans tenir compte de la couleur de l&rsquo;arri&egrave;re-fond </p>
    </td>
  </tr>
  <tr>
    <td> setXORMode(color)</td>
    <td  >Passage  en mode de dessin XOR. Deux appels successifs avec la m&ecirc;me couleur <em>color</em> s&rsquo;annulent</td>
  </tr>
  <tr>
    <td> restore()</td>
    <td  >Restore  l&rsquo;arri&egrave;re-fond pr&eacute;c&eacute;demment  sauvegard&eacute; avec <em>save()</em>.
      <div>
          <div> </div>
      </div>
    </td>
  </tr>
</table>
<p>Documentation  en ligne compl&egrave;te de la classe <em>JGameGrid </em>: <a href="http://www.jython.ch/gamegrid/dokumentation.inc.php" target="_blank">JGameGridDoc</a> </p>
<div>
  <div></div>
</div>
<p><a href="http://ch/aplu/docs/index_fr.html"><img src="gifs/home.png" alt="home" width="25" height="25"></a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
</body>
</html>
