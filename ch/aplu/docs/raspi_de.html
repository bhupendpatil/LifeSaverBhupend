<html>
<head>
</head>
<body font face="Arial, Helvetica, sans-serif">
<h2><a href="http://ch/aplu/docs/index_de.html"><img src="gifs/home.png" alt="home" width="25" height="25"></a></h2>
<h2>Dokumentation Raspberry Pi GPIO (RPi_GPIO)</h2>
<p>&nbsp;</p>
<h4>Allgemeines:</h4>
<p>Das General Purpose Input Output System des Raspberry Pi hat 17 Datenleitungen (Rev.B board: 26), die individuell als Eingang (Input) oder Ausgang (Output) definiert werden k&ouml;nnen. Es gibt im Modul RPi_GPIO zwei Nummerierungsarten f&uuml;r die Pfostenstifte: <strong>Standardm&auml;ssig  werden die Pin-Nummern 1..26 verwendet</strong> <strong>(Rev.B board: 1..40)</strong>. Alternativ kann eine Nummerierung 0..16 (Rev.B board: 0..25) mit fortlaufenden Pins auf der einen und dann auf der anderen Seite des Pfostensteckers verwendet werden (Mode: LINE). In beiden F&auml;llen werden die Ein- bzw. Ausg&auml;nge als channels bezeichnet.
<table width="752" border="0">
  <tr>
    <td width="89">&nbsp;</td>
    <td width="653"><img src="gifs/GPIOPins.png" alt="GPIOPins" width="664" height="401"></td>
  </tr>
</table>
<p><strong>Das Programm muss als Root User (mit Supervisor Rechten) laufen, damit es auf das GPIO-System zugreifen kann!</strong>

<p>Das API ist weitgehend kompatibel zum Python-Modul <a href="https://pypi.python.org/pypi/RPi.GPIO">RPi.GPIO</a>, so dass es einfach ist, Programme zu portieren.</p>
<p>&nbsp;</p>
<h4>Module import: from RPi_GPIO import GPIO </h4>
<h4>Klasse GPIO:</h4>
<table width="100%"  border="1" cellpadding="3" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="22%" bgcolor="#F0F0F5">Methode</td>
    <td width="78%" bgcolor="#F0F0F5">Aktion</td>
  </tr>
  <tr>
    <td> GPIO.BOARD</td>
    <td>
      <p>Konstante f&uuml;r setmode(): Channel-Nummerierung mit Pfostennummern (default). Wert: 0<br>
      </p>    </td>
  </tr>
  <tr>
    <td>GPIO.LINE</td>
    <td>Konstante f&uuml;r setmode(): Channel-Nummerierung in Reihe f&uuml;r 26-pin Stecker. Wert: 1</td>
  </tr>
  <tr>
    <td>GPIO.LINE40</td>
    <td>Konstante f&uuml;r setmode(): Channel-Nummerierung in Reihe f&uuml;r 40-pin Stecker. Wert: 2</td>
  </tr>
  <tr>
    <td>GPIO.OUT</td>
    <td>Konstante f&uuml;r setup(): Ausgangs-Channel. Wert: 0</td>
  </tr>
  <tr>
    <td>GPIO.IN</td>
    <td>Konstante f&uuml;r setup(): Eingangs-Channel. Wert: 1</td>
  </tr>
  <tr>
    <td>GPIO.LOW</td>
    <td>Logikpegel tief, entprechend 0V. Wert: 0</td>
  </tr>
  <tr>
    <td>GPIO.HIGH</td>
    <td>Logigpegel hoch, entsprechend 3.3V. Wert: 1</td>
  </tr>
  <tr>
    <td>GPIO.PUD_DOWN</td>
    <td>Konstante f&uuml;f setup(): Interner Pulldown-Widerstand. Wert: 2</td>
  </tr>
  <tr>
    <td>GPIO.PUD_UP</td>
    <td>Konstante f&uuml;f setup(): Interner Pullup-Widerstand. Wert: 3</td>
  </tr>
  <tr>
    <td>GPIO.PUD_NONE</td>
    <td>Konstante f&uuml;f setup(): Kein interner Widerstand (floating). Wert: 4</td>
  </tr>
  <tr>
    <td>GPIO.RISING</td>
    <td>Konstante f&uuml;r add_event_detect(): Triggerevent auf steigender Flanke</td>
  </tr>
  <tr>
    <td>GPIO.FALLING</td>
    <td>Konstante f&uuml;r add_event_detect(): Triggerevent auf fallender Flanke</td>
  </tr>
  <tr>
    <td>GPIO.BOTH</td>
    <td>Konstante f&uuml;r add_event_detect(): Triggerevent auf beiden Flanken</td>
  </tr>
  <tr>
    <td>GPIO.setmode(mode)</td>
    <td>w&auml;hlt den Channel-Nummerierungsmodus: BOARD oder LINE</td>
  </tr>
  <tr>
    <td>GPIO.setup(channel, ioControl, option)</td>
    <td>w&auml;hlt den Channel als Ein- oder Ausgang. Ausgang: option HIGH/LOW setzt Initialisierungswert;  Eingang: option PUD_UP, PUD_DOWN, PUD_NONE w&auml;hlt internen Pullup/down-Widerstand</td>
  </tr>
   <tr>
     <td>GPIO.cleanup()</td>
     <td>gibt alle Ressourcen frei und setzt Standardwerte</td>
   </tr>
   <tr>
     <td>GPIO.out(channel, state)</td>
     <td>setzt den Zustand eines Ausgangs-Channels</td>
  </tr>
   <tr>
     <td>GPIO.input(channel)</td>
     <td>liefert den Zustand eines Input-Channels (f&uuml;r Ausgangs-Channels den aktuell gesetzten Wert)</td>
  </tr>
   <tr>
     <td>GPIO.add_event_detect(channel, trigger)</td>
     <td>bereitet den Channel f&uuml;r Trigger-Events vor und w&auml;hlt die Triggerflanke (RISING, FALLING, BOTH)</td>
  </tr>
   <tr>
     <td>GPIO.add_event_callback(channel, callback, bounceTime)</td>
     <td>registriert f&uuml;r den Channel eine Callbackfunktion. Nach einem Triggerevent sind weitere Events w&auml;hrend der bounceTime (in ms) inaktiv. Die Callbackfunktion hat die Signatur <em>callback(channel, state) </em>mit dem aktuellen Channel und seinem Zustand</td>
   </tr>
   <tr>
     <td>GPIO.add_event_callback(channel, callback)</td>
     <td>dasselbe mit bounceTime = 0</td>
   </tr>
   <tr>
     <td>GPIO.wait_for_edge(channel, trigger)</td>
     <td>wartet endlos auf einen Triggerevent, so wie er mit add_event_detect() definiert wurde</td>
   </tr>
   <tr>
     <td>GPIO.wait_for_edge(channel, trigger, timeout)</td>
     <td>wartet die maximale Zeit timeout (in ms) auf einen Triggerevent. Gibt 0 zur&uuml;ck, falls w&auml;hrend dieser Zeit ein Event erfolgt, sonst wird -1 zur&uuml;ckgegeben</td>
   </tr>
   <tr>
     <td>GPIO.event_detected(channel)</td>
     <td>gibt True zur&uuml;ck, falls ein mit add_event_detect() vorbereiteter Trigger seit dem letzten Aufruf eingetreten ist</td>
   </tr>
   <tr>
     <td>GPIO.getVersion()</td>
     <td>gibt die aktuelle Version als String zur&uuml;ck</td>
   </tr>
   <tr>
     <td>p = GPIO.PWM(channel, freq, duty)</td>
     <td>erzeugt und startet einen Pulse-Width-Modulation Generator mit geg. Frequenz (1..500 Hz) und geg. duty cycle (0...100 %). Gibt eine Referenz auf PWM zur&uuml;ck</td>
   </tr>
   <tr>
     <td>p = GPIO.PWM(channel, freq)</td>
     <td>erzeugt  einen Pulse-Width-Modulation Generator mit geg. Frequenz (1..500 Hz), startet ihn aber nicht (duty = 0).. Gibt eine Referenz auf PWM zur&uuml;ck</td>
   </tr>
   <tr>
     <td>p.start(duty)</td>
     <td>startet oder setzt den PWM mit geg. duty cycle (0..100 %)</td>
   </tr>
   <tr>
     <td>p.changeDutyCycle(duty)</td>
     <td>startet oder setzt den PWM mit geg. duty cycle (0..100 %)</td>
   </tr>
   <tr>
     <td>p.stop()</td>
     <td>stoppt den PWM (setzt duty = 0)</td>
   </tr>
   
   <tr>
     <td>GPIO.delay(ms)</td>
     <td>h&auml;lt den Prozess w&auml;hrend ms Millisekunden an</td>
   </tr>
</table>

<h4>&nbsp;</h4>
<h4><a href="http://ch/aplu/docs/index_de.html"></a><a href="http://ch/aplu/docs/index_de.html"><img src="gifs/home.png" alt="home" width="25" height="25"></a></h4>
<p>&nbsp;</p>
</body>
</html>

