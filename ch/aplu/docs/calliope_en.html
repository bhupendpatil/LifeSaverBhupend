<!--Dokumentation Turtlegrafik-->
<html>
<head>
<style type="text/css">
<!--
.Stil2 {
	font-size: large;
	font-weight: bold;
}
-->
</style>
</head>
<body font face="Arial, Helvetica, sans-serif">



<p><a href="http://ch/aplu/docs/index_en.html"><img src="gifs/home.png" alt="home" width="25" height="25"></a></p>
<p>(English translation coming soon)</p>
<h2>Dokumentation Calliope Mini</h2>
<p>3.3V Spannungsversorgung externer Ger&auml;te: Maximal 100 mA</p>
<h3>Modul import: from calliope_mini import *</h3>
<strong><font size="+1">Direkte Funktionsaufrufe</font></strong> <br>
(Realmodus)<br>
<table width="100%"  border="1" cellpadding="4" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="28%" bgcolor="#F0F0F5">Funktion</td>
    <td width="62%" bgcolor="#F0F0F5">Aktion</td>
  </tr>
  <tr>
    <td>panic(n)</td>
    <td >blockiert das System und zeigt endlos ein &quot;Trauriggesicht&quot; gefolgt von n (f&uuml;r Entwickler)</td>
  </tr>
  <tr>
    <td>reset()</td>
    <td >startet das System neu (f&uuml;hrt main.py aus)</td>
  </tr>
  <tr>
    <td>sleep(dt)</td>
    <td >h&auml;lt das Programm w&auml;hrend dt Millisekunden an</td>
  </tr>
  <tr>
    <td>running_time()</td>
    <td >gibt die Zeit in Millisekunden zur&uuml;ck, seit das Board eingeschaltet oder resetted wurde</td>
  </tr>
  <tr>
    <td>temperature()</td>
    <td >gibt die Temperatur im Lagesensor in Grad Celsius zur&uuml;ck (als Float)</td>
  </tr>
</table>
<br>
<br>
<hr>
<br>
<font size="+1"><strong>Buttons</strong></font><br>
(Real- und Simulationsmodus)
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td>button_a</td>
    <td >Instanz des Buttons A</td>
  </tr>
  <tr>
    <td width="28%">button_b</td>
    <td width="62%">Instanz des Buttons B</td>
  </tr>
</table>
<strong><br>
Methoden:</strong>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td>is_pressed()</td>
    <td >gibt True zur&uuml;ck, falls der Button beim Aufruf gedr&uuml;ckt ist; andernfalls False</td>
  </tr>
  <tr>
    <td width="28%">was_pressed()</td>
    <td width="62%">gibt True zur&uuml;ck, falls der Button seit dem letzten Aufruf (oder dem Start des Programms) gedr&uuml;ckt wurde. Ein erneuter Aufruf gibt False zur&uuml;ck, bis der Button wieder gedruckt wird</td>
  </tr>
  <tr>
    <td>get_presses()</td>
    <td>gibt die Anzahl Tastenbet&auml;tigungen seit dem letzten Aufruf (oder dem Start des Programms) zur&uuml;ck. Ein erneuter Aufruf gibt 0 zur&uuml;ck, bis die Taste wieder bet&auml;tigt wird</td>
  </tr>
</table>
<p><br>
    <strong>Beispiel: </strong><br>
    <font face="Courier New, Courier, monospace">if button_a.was_pressed():</font><br>
    <font face="Courier New, Courier, monospace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mache_etwas</font></p>
<p><strong>Bemerkung: </strong><br>
  Im Simulationsmodus dr&uuml;ckt man einen Button mit der linken Maustaste. Bet&auml;tigt man die rechte Maustaste, so wird der Button im gedr&uuml;ckten Zustand gehalten, bis man wieder mit einer Maustaste dr&uuml;ckt. Damit kann man das gleichzeitige Dr&uuml;cken der Tasten simulieren. <br>
</p>
<hr>
<br>
<strong><font size="+1">FarbLED</font></strong><br>
(Real- und Simulationsmodus)
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="28%">led</td>
    <td width="62%" >Instanz der FarbLED</td>
  </tr>
</table>
<strong><br>
Methoden:</strong>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td>set_red(r)</td>
    <td >setzt die rote Farbkomponente (die anderen bleiben gleich) r = 0..255</td>
  </tr>
  <tr>
    <td>set_green(g)</td>
    <td >setzt die gr&uuml;ne Farbkomponente (die anderen bleiben gleich) g = 0..255</td>
  </tr>
  <tr>
    <td>set_blue(r)</td>
    <td >setzt die blaue Farbkomponente (die anderen bleiben gleich) b = 0..255</td>
  </tr>
  <tr>
    <td>get_red()</td>
    <td >liefert die rote Farbkomponente zur&uuml;ck</td>
  </tr>
  <tr>
    <td>get_green()</td>
    <td >liefert die gr&uuml;ne Farbkomponente zur&uuml;ck</td>
  </tr>
  <tr>
    <td>get_blue()</td>
    <td >liefert die blaue Farbkomponente zur&uuml;ck</td>
  </tr>
  <tr>
    <td>set_colors(r, g, b)</td>
    <td >setzt die drei Farbkomponenten r, g, b = 0..255</td>
  </tr>
  <tr>
    <td>get_colors()</td>
    <td>liefert die drei Farbkomponenten als Tupel zur&uuml;ck</td>
  </tr>
  <tr>
    <td width="28%">clear()</td>
    <td width="62%">setzt alle drei Farbkomponenten auf 0</td>
  </tr>
</table>
<p></p>
<hr>
<br>
<strong><font size="+1">Display</font> </strong><br>
(Real- und Simulationsmodus)<br>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="28%">display</td>
    <td width="62%" >Instanz des Displays</td>
  </tr>
</table>
<br>
<strong>Methoden:</strong>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td>set_pixel(x, y, value)</td>
    <td >setzt die Intensit&auml;t des Pixels an der Position x, y. value ist im Bereich 0..9</td>
  </tr>
  <tr>
    <td>get_pixel(x, y)</td>
    <td >liefert den Wert des Pixels an der Position x, y</td>
  </tr>
  <tr>
    <td>clear()</td>
    <td >l&ouml;scht alle Pixels</td>
  </tr>
  <tr>
    <td>on()/off()</td>
    <td >schaltet den Display an/aus. Im ausgeschalteten Zustand stehen folgende Pins zus&auml;tzlich als I/O zur Verf&uuml;gung: pin4, pin6, pin7, pin9</td>
  </tr>
  <tr>
    <td>show(str)</td>
    <td >schreibt str auf dem LED-Display aus. Enth&auml;lt dieser mehrere Zeichen, so werden diese in Laufschrift angezeigt, die auf dem letzten Zeichen stehen bleibt </td>
  </tr>
  <tr>
    <td>show(list_of_img, delay = 400,  loop = False, wait = True, clear = False)</td>
    <td>zeigt alle Images der Liste nacheinander an. Falls loop = True ist, wird die Anzeigesequenz endlos wiederholt. F&uuml;r wait = True ist die Methode blockierend, andernfalls kehrt sie zur&uuml;ck und die Anzeige erfolge im Hintergrund. delay ist die Anzeigezeit pro Bild in Millisekunden (default: 400). F&uuml;r clear = True wird die Anzeige nach dem letzten Bild gel&ouml;scht</td>
  </tr>
  <tr>
    <td width="28%">show(img)</td>
    <td width="62%">zeigt das img auf dem LED-Display. Ist img gr&ouml;sser als 5x5 pixels, so wird der Bereich x, y = 0..4 angezeigt. Ist img kleiner als 5x5 pixels, sind die fehlenden Pixels ausgeschaltet</td>
  </tr>
  <tr>
    <td>scroll(str)</td>
    <td>zeigt str als Laufschrift. Das letzte Zeichen verschwindet (blockierende Methode)</td>
  </tr>
  <tr>
    <td>scroll(str, delay = 150,  loop = False, wait = True, monospace = False)</td>
    <td>zeigt str als Laufschrift.  Falls loop = True ist, wird die Anzeigesequenz endlos wiederholt. F&uuml;r wait = True ist die Methode blockierend, andernfalls kehrt sie zur&uuml;ck und die Anzeige erfolge im Hintergrund. delay ist die Anzeigezeit pro Spalte  in Millisekunden (default: 150)</td>
  </tr>
</table>
<strong><br>
Beispiele: </strong><br>
<font face="Courier New, Courier, monospace">display.show(&quot;A&quot;)</font><br>
<font face="Courier New, Courier, monospace">display.scroll(&quot;Hallo&quot;)</font><font face="Courier New, Courier, monospace"><br>
display.show([Image.HAPPY, Image.SAD])</font><br>
<br>
<br>
<hr>
<br>
<font size="+1"><strong>Image</strong> </font><br>
(Real- und Simulationsmodus)<br>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td>Image(str)</td>
    <td >
      <p>erzeugt eine Instanz. str hat das Format &quot;aaaaa:bbbbb:ccccc:ddddd:eeeee:&quot;, wo a eine Zahl im Bereich 0..9 ist, welche die Intensit&auml;t des Pixels angibt. a sind die Werte f&uuml;r die erste Zeile, b f&uuml;r die zweite, usw.</p>
    </td>
  </tr>
  <tr>
    <td width="28%">Image()</td>
    <td width="62%">erzeugt eine Instanz mit 5x5 ausgeschalteten Pixels</td>
  </tr>
  <tr>
    <td>Image(width, height)</td>
    <td>erzeugt eine Instanz mit der gegebenen Zahl horizontaler und vertikaler Pixel, die alle ausgeschaltet sind (value = 0)</td>
  </tr>
</table>
<br>
<strong>Methoden:</strong>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td>set_pixel(x, y, value)</td>
    <td >setzt die Intensit&auml;t des Pixels an der Position x, y. value ist im Bereich 0..9</td>
  </tr>
  <tr>
    <td>fill(value)</td>
    <td>setzt die Intensit&auml;t aller Pixels auf den gleichen Wert (value = 0..9) </td>
  </tr>
  <tr>
    <td>get_pixel(x, y)</td>
    <td>gibt die Intensit&auml;t des Pixels an der Position x, y</td>
  </tr>
  <tr>
    <td width="28%">shift_left(n)</td>
    <td width="62%">gibt ein Image-Objekt zur&uuml;ck, das um n Spalten nach links verschoben ist (rechts eingeschobene Spalten sind ausgeschaltet)</td>
  </tr>
  <tr>
    <td>shift_right(n)</td>
    <td>gibt ein Image-Objekt zur&uuml;ck, das um n Spalten nach rechts verschoben ist (links eingeschobene Spalten sind ausgeschaltet)</td>
  </tr>
  <tr>
    <td>shift_up(n)</td>
    <td>gibt ein Image-Objekt zur&uuml;ck, das um n Zeilen nach oben verschoben ist (unten eingeschobene Spalten sind ausgeschaltet)</td>
  </tr>
  <tr>
    <td>shift_down(n)</td>
    <td>gibt ein Image-Objekt zur&uuml;ck, das um n Zeilen nach unten verschoben ist (oben eingeschobene Spalten sind ausgeschaltet)</td>
  </tr>
  <tr>
    <td>copy()</td>
    <td>gibt einen Klone des Image zur&uuml;ck</td>
  </tr>
  <tr>
    <td>invert()</td>
    <td>gibt ein Image-Objekt mit invertieren Pixels zur&uuml;ck (new_value = 9 - value)</td>
  </tr>
  <tr>
    <td>crop(x, y, w, h)</td>
    <td>gibt einen Bildausschnitt der Breite w und H&ouml;he h zur&uuml;ck. Die obere linke Ecke entspricht dem Pixel x, y des Originalbildes</td>
  </tr>
  <tr>
    <td>dest.blit(img, x, y, w, h, xdest, ydest)</td>
    <td>kopiert vom gegebenen img einen rechteckigen Bereich an der Position x, y mit Breite w und H&ouml;he h in das Image dest an der Stelle xdest, ydest</td>
  </tr>
</table>
<strong><br>
Operationen:</strong>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td>image_new = image * n</td>
    <td >gibt ein Image-Objekt zur&uuml;ck, bei dem alle Pixel-Intensit&auml;ten mit dem Faktor n multipliziert sind</td>
  </tr>
  <tr>
    <td width="28%">image_new = image1 + image2</td>
    <td width="62%">gibt ein Image-Objekt zur&uuml;ck, bei dem die Intensit&auml;ten der Pixel von image1 und image2 addiert wurden</td>
  </tr>
</table>
<strong><br>
</strong>
<p><strong><br>
  Vordefinierte Objekte:</strong></p>
<ul>
  <li><font size="-1">Image.HEART</font></li>
  <li><font size="-1">Image.HEART_SMALL</font></li>
  <li><font size="-1">Image.HAPPY</font></li>
  <li><font size="-1">Image.SMILE</font></li>
  <li><font size="-1">Image.SAD</font></li>
  <li><font size="-1">Image.CONFUSED</font></li>
  <li><font size="-1">Image.ANGRY</font></li>
  <li><font size="-1">Image.ASLEEP</font></li>
  <li><font size="-1">Image.SURPRISED</font></li>
  <li><font size="-1">Image.SILLY</font></li>
  <li><font size="-1">Image.FABULOUS</font></li>
  <li><font size="-1">Image.MEH</font></li>
  <li><font size="-1">Image.YES</font></li>
  <li><font size="-1">Image.NO</font></li>
  <li><font size="-1">Image.CLOCK12, Image.CLOCK11, Image.CLOCK10, Image.CLOCK9,  Image.CLOCK8, Image.CLOCK7, Image.CLOCK6, Image.CLOCK5,  Image.CLOCK4, Image.CLOCK3, Image.CLOCK2, Image.CLOCK1</font></li>
  <li><font size="-1">Image.ARROW_N, Image.ARROW_NE, Image.ARROW_E,  Image.ARROW_SE, Image.ARROW_S, Image.ARROW_SW,  Image.ARROW_W, Image.ARROW_NW</font></li>
  <li><font size="-1">Image.TRIANGLE</font></li>
  <li><font size="-1">Image.TRIANGLE_LEFT</font></li>
  <li><font size="-1">Image.CHESSBOARD</font></li>
  <li><font size="-1">Image.DIAMOND</font></li>
  <li><font size="-1">Image.DIAMOND_SMALL</font></li>
  <li><font size="-1">Image.SQUARE</font></li>
  <li><font size="-1">Image.SQUARE_SMALL</font></li>
  <li><font size="-1">Image.RABBIT</font></li>
  <li><font size="-1">Image.COW</font></li>
  <li><font size="-1">Image.MUSIC_CROTCHET</font></li>
  <li><font size="-1">Image.MUSIC_QUAVER</font></li>
  <li><font size="-1">Image.MUSIC_QUAVERS</font></li>
  <li><font size="-1">Image.PITCHFORK</font></li>
  <li><font size="-1">Image.XMAS</font></li>
  <li><font size="-1">Image.PACMAN</font></li>
  <li><font size="-1">Image.TARGET</font></li>
  <li><font size="-1">Image.TSHIRT</font></li>
  <li><font size="-1">Image.ROLLERSKATE</font></li>
  <li><font size="-1">Image.DUCK</font></li>
  <li><font size="-1">Image.HOUSE</font></li>
  <li><font size="-1">Image.TORTOISE</font></li>
  <li><font size="-1">Image.BUTTERFLY</font></li>
  <li><font size="-1">Image.STICKFIGURE</font></li>
  <li><font size="-1">Image.GHOST</font></li>
  <li><font size="-1">Image.SWORD</font></li>
  <li><font size="-1">Image.GIRAFFE</font></li>
  <li><font size="-1">Image.SKULL</font></li>
  <li><font size="-1">Image.UMBRELLA</font></li>
  <li><font size="-1">Image.SNAKE</font></li>
  <li><font size="-1"> Listen:
    Image.ALL_CLOCKS,  Image.ALL_ARROWS</font></li>
</ul>
<blockquote>
  <div></div>
</blockquote>
<p><strong>Bemerkung: </strong><br>
  Ein Image-Objekt (kurz ein &quot;Image&quot;) ist eine Abstraktion eines realen Pixelbildes und wird erst sichtbar, wenn <font face="Courier New, Courier, monospace">display.show(img)</font> aufgerufen wird. Das Image kann eine beliebige Zahl horizontaler und vertikaler Pixels (w, h) haben, aber es werden mit <font face="Courier New, Courier, monospace">show(img)</font> nur die Pixels im Bereich x = 0..4, y = 0..4 angezeigt. (Ist das Image kleiner, so sind die nicht definierten Pixels dunkel.)</p>
<p>Man beachte, dass einige Methoden nicht das Bild selbst modifizieren, sondern ein modifiziertes Bild zur&uuml;ckgeben. Um <font face="Courier New, Courier, monospace">img</font> zu &auml;ndern, kann man ihm das neue Bild zuweisen.</p>
<p><strong></strong><br>
    <strong>Beispiele: </strong><br>
    <font face="Courier New, Courier, monospace">img = Image(2, 2)<br>
      img = img.invert()<br>
      display.show(img)<br>
    </font><span class="Stil2"><br>
  </span></p>
<hr>
<p><br>
    <strong><font size="+1">General Purpose I/O (GPIO)</font></strong><br>
  (Real- und Simulationsmodus nur *)</p>
<p>Output: 5 mA  maximal pro Anschluss 15 mA maximale Last (alle Anschl&uuml;sse zusammen)</p>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="28%">pin0*, pin1*, pin2*, pin3*, pin18, pin21...pin30</td>
    <td width="62%" >Instanzen f&uuml;r allgemeines Digital-in/Digital-out oder Analog-in/Analog-out (PWM)</td>
  </tr>
  <tr>
    <td>pin4... pin15</td>
    <td>Instanzen vordefiniert f&uuml;r LED display (display mode)</td>
  </tr>
  <tr>
    <td>pin16, pin17</td>
    <td>Instanzen vordefiniert f&uuml;r  Button A, B (button mode)</td>
  </tr>
  <tr>
    <td>pin19, pin20</td>
    <td>Instanzen vordefiniert f&uuml;r I2C (i2c mode)</td>
  </tr>
</table>
<br>
<strong>Methoden:</strong>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td>read_digital()</td>
    <td >gibt 1 zur&uuml;ck, falls Pin auf logisch 1 (HIGH) ist; gibt 0 zur&uuml;ck, falls Pin auf logisch 0 (LOW) ist (Pulldown 10 kOhm)</td>
  </tr>
  <tr>
    <td width="28%">write_digital(v)</td>
    <td width="62%">falls  v = 1, wird der Pin auf logisch 1 (HIGH) gesetzt; fals v = 0, wird der Pin auf logisch 0 (LOW) gesetzt (max. Strom: 5 mA)</td>
  </tr>
  <tr>
    <td>read_analog()</td>
    <td>gibt Wert des ADC im Bereich  0..1023 zur&uuml;ck (Eingangsimpedanz:  10&nbsp;MOhm) (nur pin1, pin2, pin3, auf pin3 ist der Ausgang des Mikrofon-Verst&auml;rkers)</td>
  </tr>
  <tr>
    <td>write_analog(v)</td>
    <td>setzt den PWM Duty Cycle (v = 0..1023 entsprechend 0..100%) (max. Strom: 5&nbsp;mA)</td>
  </tr>
  <tr>
    <td>set_analog_period(period)</td>
    <td>setzt die PWM-Periode in Millisekunden</td>
  </tr>
  <tr>
    <td>set_analog_period_microseconds(period)</td>
    <td>setzt die PWM-Periode in Mikrosekunden (&gt; 300)</td>
  </tr>
  <tr>
    <td>set_pull(mode)</td>
    <td>setzt den Pullup/Pulldown-Widerstand. (mode: pinx.PULL_UP, pinx.PULL_DOWN, pinx.NO_PULL). Default: Pulldown-Widerstand)</td>
  </tr>
</table>
<br>
<br>
<hr>
<font size="+1"><strong><br>
Accelerometer</strong></font> <br>
(Real- und Simulationsmodus)<br>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="28%">accelerometer</td>
    <td width="62%" >Instanz des Beschleunigungssensors</td>
  </tr>
</table>
<br>
<strong>Methoden:</strong>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td>get_x(), get_y(), get_z()</td>
    <td >gibt die Beschleunigung in  x-, y- oder z-Richtung zur&uuml;ck (int,   Bereich ca. -2047 bis +2048, entsprechend ungef&auml;hr -20 m/s^2 bis +20 m/s^2, die Erdbeschleunigung von ungef&auml;hr 10 m/s^2 wird mitgez&auml;hlt). x-Richtung: FarbLed-USB; y-Richtung: ButtonB-ButtonA;  z-Richtung: Normale zum Board von vorne nach hinten</td>
  </tr>
  <tr>
    <td width="28%">get_values()</td>
    <td width="62%">gibt ein Tupel mit den Beschleunigungen in   x-, y- oder z-Richtung zur&uuml;ck (Einheit wie oben)</td>
  </tr>
</table>
<br>
<br>
<hr>
<br>
<strong><font size="+1">Magnetometer</font></strong><br>
(nur Realmodus)<br>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="28%">magnetometer</td>
    <td width="62%" >Instanz des Magnetfeldsensors</td>
  </tr>
</table>
<br>
<strong>Methoden:</strong>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="28%">get_x(), get_y(), get_z()</td>
    <td width="62%">gibt den aktuellen Wert der x, y oder z-Komponente des Magnetfeldes an der Stelle des Sensors zur&uuml;ck (int, Mikrotesla 16-bit signed)</td>
  </tr>
</table>
<br>
<br>
<hr>
<br>
<strong><font size="+1">Gyrometer</font></strong><br>
(nur Realmodus)
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="28%">gyrometer</td>
    <td width="62%" >Instanz des Drehzahlmessers</td>
  </tr>
</table>
<br>
<strong>Methods:</strong>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="28%">get_x(), get_y(), get_z()</td>
    <td width="62%">gibt den aktuellen Wert der x, y oder z-Komponente des Winkelgeschwindigkeit</td>
  </tr>
  <tr>
    <td>get_values()</td>
    <td>gibt ein Tupel der    x-, y- und z-Komponenten der Winkelgeschwindigkeit</td>
  </tr>
</table>
<br>
<br>
<hr>
<strong><font size="+1"></font></strong><br>
<strong><font size="+1"> NeoPixel</font></strong> <font size="-1"><br>
</font>(nur Realmodus)<font size="-1"><br>
(<strong>Modul import: from neopixel import *</strong>)</font>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="28%">np = NeoPixel(pin, n)</td>
    <td width="62%" >
      <p>erzeugt eine Instanz mit n Neopixels, die an den gegebenen Pin angeschlossen sind. Jeder Pixel wird durch seine Position adressiert (beginnend bei 0) und seine Farbe wird durch eine Zuweisung eines RGB-Tupels bestimmt, z.B.  np[2] = (0, 100, 255) setzt Pixel # 2 auf Rot = 0, Gr&uuml;n = 100, Blue = 255. <em>show()</em> muss aufgerufen werden, damit die &Auml;nderung sichbar wird.</p>
      <p>(Strips mit WS2812 LEDs unterst&uuml;tzt.)</p>
    </td>
  </tr>
</table>
<br>
<strong>Methods:</strong>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td>clear()</td>
    <td >
      <p>l&ouml;scht  alle Pixels</p>
    </td>
  </tr>
  <tr>
    <td width="28%">show()</td>
    <td width="62%">zeigt die Pixels an. Muss bei jeder &Auml;nderung der Farbwerte aufgerufen werden, damit diese sichbar ist</td>
  </tr>
</table>
<br>
<br>
<hr>
<p></p>
<p><strong><font size="+1">Modul music</font></strong> <br>
  (nur Realmodus)<br>
  <font size="-1"> (<strong>Modul import: from music import *</strong>)</font><br>
</p>
<strong>Funktionen:</strong>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td>set_tempo(bpm = 120)</td>
    <td >setzt die Anzahl  Beats pro Minute (default: 120)</td>
  </tr>
  <tr>
    <td width="28%">pitch(frequency, len, pin = pin0, wait = True)</td>
    <td width="62%">spielt einen Ton mit gegebener Frequenz in Hertz w&auml;hrend der gegebenen Zeit in Millisekunden.  pin definiert den Output-Pin am GPIO-Stecker (default: pin0). Falls wait = True, ist die Funktion blockierend; sonst kehrt sie zur&uuml;ck, w&auml;hrend der Ton weiter spielt (bis die Abspieldauer erreicht ist oder  stop() aufgerufen wird)</td>
  </tr>
  <tr>
    <td>play(melody, pin = pin0, wait = True, loop = False)</td>
    <td>spielt eine Melodie mit dem aktuellen Tempo.). pin definiert den Output-Pin am GPIO-Stecker (default: pin0). Falls wait = True, ist die Funktion blockierend; sonst kehrt sie zur&uuml;ck, w&auml;hrend die Melodie weiter spielt (bis die Abspieldauer erreicht ist oder  stop() aufgerufen wird). Falls  loop = True, wird die Melodie endlos erneut abgespielt</td>
  </tr>
  <tr>
    <td>stop(pin = pin0)</td>
    <td>stoppt alle Sound-Ausgaben am gegebenen GPIO-Pin (default: pin0)</td>
  </tr>
</table>
<p><strong>Bemerkungen:</strong> <br>
  Eine Melodie ist eine Liste mit Strings in folgendem Format:  [&quot;note:dauer&quot;, &quot;note:dauer&quot;,...]<br>
  note in musikalischer Notation: c, d, e, f, g, a, h mit optionaler Octavezahl (default: 1): z.B.. c2, d2, ... und optionalem Versetzungszeichen (Halbtonkreuz): c#, d#,... oder c#2, d#2,...<br>
  dauer in Anzahl Ticks (optional, defaut: 1)</p>
<p>Ein Kopfh&ouml;rer oder ein aktiver Lautsprecher (mit Verst&auml;rker) kann an einem der pin0,..pin3 und GND angeschlossen werden (aber keine passiver Lautsprecher). Falls der Parameter pin ben&uuml;tzt wird, muss importiert werden: from microbit_mini import pin oder from microbit_mini import *.</p>
<p><strong>Vordefinierte Melodien:</strong></p>
<ul>
  <li><font size="-1">ADADADUM - Er&ouml;ffnung von  Beethoven&rsquo;s 5. Sinfonie in C Moll</font></li>
  <li><font size="-1">ENTERTAINER - Er&ouml;ffnungsfragment von Scott Joplin&rsquo;s Ragtime Klassiker &ldquo;The Entertainer&rdquo;</font></li>
  <li><font size="-1">PRELUDE -Er&ouml;ffnung des ersten Prelude in C Dur von J.S.Bach&rsquo;s 48 Preludien und Fugen</font></li>
  <li><font size="-1">ODE - &ldquo;Ode an Joy&rdquo; Thema aus  Beethoven&rsquo;s 9. Sinfonie in D Moll</font></li>
  <li><font size="-1">NYAN - das Nyan Cat Thema</font></li>
  <li><font size="-1">RINGTONE - ein Klingelton</font></li>
  <li><font size="-1">FUNK - ein Ger&auml;usch f&uuml;r Geheimagenten </font></li>
  <li><font size="-1">BLUES - ein Boogie-Woogie Blues</font></li>
  <li><font size="-1">BIRTHDAY - &ldquo;Happy Birthday to You...&rdquo;</font></li>
  <li><font size="-1">WEDDING - der Chorus des Br&auml;utigams aus Wagner&rsquo;s Oper &ldquo;Lohengrin&rdquo;</font></li>
  <li><font size="-1">FUNERAL - der &ldquo;Trauerzug&rdquo;, auch bekannt als Fr&eacute;d&eacute;ric Chopin&rsquo;s Klaviersonate No. 2 in B&#9837;Moll</font></li>
  <li><font size="-1">PUNCHLINE - a lustiger Tonclip, nachdem ein Witz gemacht wurde</font></li>
  <li><font size="-1">PYTHON   - John Philip Sousa&rsquo;s Marsch &ldquo;Liberty Bell&rdquo;, ein Thema aus &ldquo;Monty   Python&rsquo;s Flying Circus&rdquo;</font></li>
  <li><font size="-1">BADDY - Filmclip aus &quot;The Baddy</font>&quot;</li>
  <li><font size="-1">CHASE - Filmclick aus einer Jagdszene</font></li>
  <li><font size="-1">BA_DING - ein Signalton, der darauf hinweist, dass etwas geschehen ist</font></li>
  <li><font size="-1">WAWAWAWAA - ein trauriger Posaunenklang</font></li>
  <li><font size="-1">JUMP_UP - f&uuml;r Spiele, um auf eine Aufw&auml;rtsbewegung hinzuweisen</font></li>
  <li><font size="-1">JUMP_DOWN - f&uuml;r Spiele, um auf eine Abw&auml;rtsbewegung hinzuweisen</font></li>
  <li><font size="-1">POWER_UP - ein Fanfarenklang, der darauf hinweist, dass etwas erreicht wurde</font></li>
  <li><font size="-1">POWER_DOWN - ein trauriger Fanfarenklang, der darauf hinweist, dass etwas verloren gegangen ist</font><br>
      <br>
  </li>
</ul>
<hr>
<br>
<p><strong><font size="+1">Modul radio:</font></strong><br>
  (nur Realmodus)<br>
  <font size="-1">(<strong>Modul import: from radio import *</strong>)</font><br>
  <font size="-1"><br>
</font>Computerkommunikation &uuml;ber Bluetooth</p>
<strong>Funktionen:</strong>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td>on()</td>
    <td >schaltet die Bluetooth-Kommunikation ein. Verbindet mit einem micro:bit mit eingeschaltetem Bluetooth</td>
  </tr>
  <tr>
    <td width="24%">off()</td>
    <td width="76%">schaltet die Bluetooth-Kommunikation aus</td>
  </tr>
  <tr>
    <td>send(msg)</td>
    <td>sendet eine String-Message in den Messagebuffer des Empf&auml;ngerknotens  (First-In-First-Out, FIFO-Buffer)</td>
  </tr>
  <tr>
    <td>msg = receive()</td>
    <td>
      <p>gibt die &auml;lteste Message  (string) des Messagebuffers zur&uuml;ck und entfernt sie aus dem Buffer. Falls der Buffer leer ist, wird None zur&uuml;ckgegeben. Es wird vorausgesetzt, dass  die Messages mit send(msg) gesendet wurden, damit sie sich in Strings umwandeln lassen [sonst wird eine ValueError Exception (&quot;received packet is not a string&quot;) geworfen]</p>
    </td>
  </tr>
  <tr>
    <td>send_bytes(msg_bytes)</td>
    <td>sendet eine Message als Bytes (Klasse <em>bytes, e.g b'\x01</em>\x48') in den Messagebuffer des Empf&auml;ngerknotens (First-In-First-Out, FIFO-Buffer) </td>
  </tr>
  <tr>
    <td>receive_bytes()</td>
    <td>
      <p>gibt die &auml;lteste Message (bytes) des  Messagebuffers zur&uuml;ck und entfernt sie aus dem Buffer. Falls der Buffer leer ist, wird None zur&uuml;ckgegeben. Zum Senden muss send_bytes(msg) verwendet werden (und nicht send(msg))</p>
    </td>
  </tr>
</table>
<br>
<br>
<br>
<hr>
<br>
<p><strong><font size="+1">Modul cpmike:</font></strong><br>
  (nur Realmodus)<br>
  <font size="-1">(<strong>Modul import: from cpmike import *</strong>)</font><br>
  <font size="-1"><br>
</font>Detektion von Schallpulsen mit dem internen Mikrofon</p>
<strong>Funktionen:</strong>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="24%"> isClicked(level = 10, rearm_time = 500)<br>
        <br>
    </td>
    <td width="76%" >gibt True zur&uuml;ck, falls der Schallpegel im Moment des Aufrufs den vorgegebenen Pegel (level = 1...500) &uuml;bersteigt. W&auml;hrend der nachfolgenden Zeit (rearm_time in ms) ist die Detektion unterdr&uuml;ckt und es wird False zur&uuml;ckgegeben</td>
  </tr>
</table>
<br>
<br>
<hr>
<br>
<p><strong><font size="+1">Modul cp7seg:</font></strong><br>
  (nur Realmodus)<br>
  <font size="-1">(<strong>Modul import: from cp7seg import *</strong>)</font><br>
  <font size="-1"><br>
</font>Anzeige auf einem 4-stelligen 7-Segmentdisplay vom Typ TM1637 (Seed Studio), angeschlossen am analogen Grove-Port</p>
<strong>Funktionen:</strong>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="24%"> show(text)</td>
    <td width="76%" >zeigt maximal 4 Buchstaben/Zahlen/Zeichen auf dem Display an (reduziert auf 7-Segmente)</td>
  </tr>
  <tr>
    <td>color(enable)</td>
    <td >f&uuml;r enable = True, wird der Doppelpunkt angezeigt</td>
  </tr>
  <tr>
    <td>luminosity(lum)</td>
    <td >setzt die Helligkeit (lum = 1..7)</td>
  </tr>
</table>
<br>
<br>
<hr>
<br>
<p><strong><font size="+1">Modul sht32:</font></strong><br>
  (nur Realmodus)<br>
  <font size="-1">(<strong>Modul import: from sht32 import *</strong>)</font><br>
  <font size="-1"><br>
</font>Hochpr&auml;ziser Temperatur-/Feuchtigkeitssensor SHT32 von Sensirion, angeschlossen am Grove-I2C Port</p>
<strong>Funktionen:</strong>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="24%"> get_temp_humi()</td>
    <td width="76%" >liefert ein Tupel mit Temperatur (in Grad Celsius) und relativer Luftfeuchtigkeit (in %)</td>
  </tr>
</table>
<br>
<br>
<hr>
<br>
<p><strong><font size="+1">Modul cprover:</font></strong><br>
  (nur Realmodus)<br>
  <font size="-1">(<strong>Modul import: from cprover import *</strong>)</font><br>
  <font size="-1"><br>
</font>Gleichstrommotoren, die am Motorport angeschlossen sind</p>
<strong>Funktionen f&uuml;r zwei Motoren, die unterschiedlich vorw&auml;rts laufen:</strong>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td>forward()<br>
    </td>
    <td >schaltet beide Motoren in Vorw&auml;rtsrichtung</td>
  </tr>
  <tr>
    <td width="24%">right()</td>
    <td width="76%">schaltet den linken Motor in Vorw&auml;rtsrichtung und stoppt den rechten Motor</td>
  </tr>
  <tr>
    <td>rightArc(r)</td>
    <td>schaltet den linken Motor in Vorw&auml;rtsrichtung und verlangsamt den rechten Motor. Der Kurvenradius ist durch r bestimmt (willk&uuml;rliche Einheit)</td>
  </tr>
  <tr>
    <td>left()</td>
    <td>schaltet den rechten Motor in Vorw&auml;rtsrichtung und stoppt den linken Motor</td>
  </tr>
  <tr>
    <td>leftArc(r)</td>
    <td>schaltet den rechten Motor in Vorw&auml;rtsrichtung und verlangsamt den linken Motor. Der Kurvenradius ist durch r bestimmt (willk&uuml;rliche Einheit)</td>
  </tr>
  <tr>
    <td>stop()</td>
    <td>stoppt beide Motoren</td>
  </tr>
  <tr>
    <td>setSpeed(speed)</td>
    <td>setzt die Geschwindigkeit (speed = 1..100)</td>
  </tr>
</table>
<p><br>
  Schaltschema:<br>
  (toDo)</p>
<p><br>
    <strong>Funktionen f&uuml;r einen oder zwei Motoren, die gleichartig vorw&auml;rts oder r&uuml;ckw&auml;rts laufen:</strong></p>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td>run()<br>
    </td>
    <td >schaltet den Motor (die Motoren) in Vorw&auml;rtsrichtung</td>
  </tr>
  <tr>
    <td width="24%">back()</td>
    <td width="76%">schaltet den Motor (die Motoren) in R&uuml;ckw&auml;rtsrichtung</td>
  </tr>
  <tr>
    <td>stop()</td>
    <td>stoppt den Motor (die Motoren)</td>
  </tr>
  <tr>
    <td>setSpeed(speed)</td>
    <td>setzt die Geschwindigkeit (speed = 1..100)</td>
  </tr>
</table>
<br>
<br>
Schaltschema:<br>
(toDo)<br>
<br>
<hr>
<br>
<p><strong><font size="+1">Modul cpglow</font></strong><br>
  (Real- und Simulationsmodus)<br>
  <font size="-1">(<strong>Modul import: from cpglow import *</strong>)</font><br>
</p>
<table width="100%"  border="1" cellpadding="5" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="28%">
      <p>makeGlow()</p>
    </td>
    <td width="62%" >erzeugt einen sichtbaren Leuchtk&auml;fer mit Position (0, 0), Richtung Norden, Spur sichtbar. Koordinatensystem: -2 &lt;=x &lt;=2 (+ nach rechts), -2 &lt;= y &lt;= 2 (+ nach oben). (0, 0) auf mittlerem Pixel</td>
  </tr>
  <tr>
    <td>setSpeed()</td>
    <td>setzt die Geschwindigkeit f&uuml;r die Bewegungen (0..100)</td>
  </tr>
  <tr>
    <td>show()</td>
    <td>macht den Leuchtk&auml;fer an der aktuellen Position und f&uuml;r die n&auml;chsten Bewegungen sichtbar</td>
  </tr>
  <tr>
    <td>hide()</td>
    <td>macht den Leuchtk&auml;fer f&uuml;r die n&auml;chsten Bewegungen unsichtbar</td>
  </tr>
  <tr>
    <td>clear()</td>
    <td>l&ouml;scht alle eingeschalteten Pixels. Der Leuchtk&auml;fer bleibt an der aktuellen Position (unsichtbar)</td>
  </tr>
  <tr>
    <td>showTrace(enable)</td>
    <td>macht die Spur f&uuml;r die n&auml;chsten Bewegungen (Pixel an besuchten Stellen) sichtbar/unsichtbar</td>
  </tr>
  <tr>
    <td>forward()</td>
    <td>bewegt den Leuchtk&auml;fer um einen Schritt vorw&auml;rts</td>
  </tr>
  <tr>
    <td>back()</td>
    <td>bewegt den Leuchtk&auml;fer um einen Schritt r&uuml;ckw&auml;rts</td>
  </tr>
  <tr>
    <td>left(angle)</td>
    <td>dreht die Bewegungsrichtung um 45 Grad-Schritte nach links (angle = 45, 90, 135, 180, 215, 270, 315)</td>
  </tr>
  <tr>
    <td>right(angle)</td>
    <td>dreht die Bewegungsrichtung um 45 Grad-Schritte nach rechts (angle = 45, 90, 135, 180, 225, 270, 315)</td>
  </tr>
  <tr>
    <td>setPos(x, y)</td>
    <td>setzt den Leuchtk&auml;fer auf Position (x, y)</td>
  </tr>
  <tr>
    <td>getPos()</td>
    <td>gibt die aktuelle Position des Leuchtk&auml;fers als Tupel zur&uuml;ck</td>
  </tr>
  <tr>
    <td>isLit()</td>
    <td>gibt True zur&uuml;ck, falls das Pixel an der Stelle des Leuchtk&auml;fers eingeschaltet ist</td>
  </tr>
</table>
<strong><br>
</strong><strong></strong>
<p><br>
</p>
<h4><a href="http://ch/aplu/docs/index_en.html"><img src="gifs/home.png" alt="home" width="25" height="25"></a></h4>
<p>&nbsp;</p>
<p>&nbsp;</p>
</body>
</html>