<html>
<head>
</head>
<body font face="Arial, Helvetica, sans-serif">
<h2><a href="http://ch/aplu/docs/index_de.html"><img src="gifs/home.png" alt="home" width="25" height="25"></a></h2>
<h2>Dokumentation Robotik</h2>
<h3>Module imports: </h3>
<h3>from simrobot import *<br>
  from nxtrobot import *<br>
  from ev3robot import *<br />
</h3>
<h4>LegoRobot:</h4>

<table width="100%"  border="1" cellpadding="3" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="30%" bgcolor="#F0F0F5">Methode</td>
    <td width="70%" bgcolor="#F0F0F5">Aktion</td>
  </tr>
  <tr>
    <td> LegoRobot()</td>
    <td>
      <p>erzeugt Roboter (ohne Motoren) und stellt die Verbindung zum Roboter her<br>
        <em>Simulationsmodus:</em> erstellt Simulationsfenster<br>
      </p>
    </td>
  </tr>
  <tr>
    <td>addPart(part)</td>
    <td>f&uuml;gt eine Komponente zum Roboter</td>
  </tr>
   <tr>
     <td>clearDisplay()</td>
     <td>L&ouml;scht die Anzeige [<em>Simulationsmodus:</em> Status bar]</td>
   </tr>
   <tr>
     <td>drawString(text, x, y)</td>
     <td>Schreibt text an Position x, y [<em>Simulationsmodus:</em> in Status bar, (x, y) irrelevant]</td>
  </tr>
   <tr>
     <td>isEnterHit()</td>
     <td>True, falls vorher die ENTER-Taste gedr&uuml;ckt wurde [<em>NXT und Simulationsmodus:</em> Tastaturtaste<em> Enter (cr)</em>]</td>
   </tr>
   <tr>
     <td>isEscapeHit()</td>
     <td>True, falls vorher die ESCAPE-Taste gedr&uuml;ckt wurde [<em>NXT und Simulationsmodus:</em> Tastaturtaste <em>Escape</em>]</td>
   </tr>
   <tr>
     <td>isLeftHit()</td>
     <td>True, falls vorher die LEFT-Taste gedr&uuml;ckt wurde [<em>NXT und Simulationsmodus:</em> Tastaturtaste <em>Cursor-Left</em>]</td>
  </tr>
   <tr>
     <td>isRightHit()</td>
     <td>True, falls vorher die RIGHT-Taste gedr&uuml;ckt wurde [<em>NXT und Simulationsmodus:</em> Tastaturtaste <em>Cursor-Right</em>]</td>
   </tr>
   <tr>
     <td>isUpHit()</td>
     <td>True, falls vorher UP-Taste gedr&uuml;ckt wurde [<em>NXT und Simulationsmodus:</em> Tastaturtaste <em>Cursor-Up</em>]</td>
   </tr>
   <tr>
     <td>isDownHit()</td>
     <td>True, falls vorher die DOWN-Taste gedr&uuml;ckt wurde [<em>NXT und Simulationsmodus:</em> Tastaturtaste <em>Cursor-Down</em>]</td>
   </tr>
   <tr>
     <td>playTone(frequency, duration)</td>
     <td>spielt einen Ton mit geg, Frequenz (in Hz)  w&auml;hrend der geg. Zeit (ms) </td>
  </tr>
   <tr>
     <td>setVolume(volume)</td>
     <td>setzt die Lautst&auml;rke f&uuml;r alle Tonausgaben (0..100)</td>
   </tr>
   <tr>
       <td>playSample(tag, volume)</td>
       <td>spielt mit der Lautst&auml;rke volume (0..100) eine WAV Datei aus dem Verzeichnis <em>/home/root/music</em> mit dem Dateinamen <em>song&lt;tag&gt;.wav</em> ab (<em>tag</em>: integer) (Funktion nicht blockierend). WAV format:  mono, 8 bit unsigned oder 16 bit signed mit maximaler Samplingrate 11025 Hz. [<em>Simulationsmodus:</em> nicht verf&uuml;gbar]</td>
   </tr>
   <tr>
       <td>playSampleWait(tag, volume)</td>
       <td>dasselbe, aber Funktion blockierend, bis Datei fertig abgespielt. [<em>Simulationsmodus:</em> nicht verf&uuml;gbar]</td>
   </tr>
   <tr>
     <td>setLED(pattern)</td>
     <td>setzt EV3-LEDS: 0: aus, 1: gr&uuml;n, 2: rot, 3: rot hell, 4: gr&uuml;n blinkend, 5: rot blinkend, 6: rot blinkend hell, 7: gr&uuml;n doppelblinkend, 8: rot doppelblinkend, 9: rot doppelblinkend hell</td>
   </tr>
   <tr>
    <td>exit()</td>
    <td>stoppt den Roboter und beendet die Bluetooth-Verbindung</td>
  </tr>
  <tr>
    <td>isConnected()</td>
    <td>gibt True zur&uuml;ck, falls  Verbindung besteht [<em>Simulationsmodus:</em> Fenster nicht geschlossen]</td>
  </tr>
 <tr>
    <td>reset()</td>
    <td><em>Simulationsmodus:</em> setzt den Roboter an die Startposition/Startrichtung</td>
  </tr>
</table>

<h4><br>
Gear:</h4>
<table width="100%"  border="1" cellpadding="3" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="30%">Gear()</td>
    <td width="70%">erzeugt ein Fahrwerk mit 2 synchronisierten Motoren</td>
  </tr>
   <tr>
    <td>backward()</td>
    <td>f&auml;hrt r&uuml;ckw&auml;rts (nicht-blockierende Methode)</td>
  </tr>
  <tr>
    <td>backward(ms)</td>
    <td>f&auml;hrt w&auml;hrend gegebener Zeit (in ms) r&uuml;ckw&auml;rts (blockierende Methode)</td>
  </tr>
  <tr>
    <td> isMoving()</td>
    <td>gibt true zur&uuml;ck, wenn das Fahrwerk in Bewegung ist</td>
  </tr>
   <tr>
    <td>forward()</td>
    <td>f&auml;hrt vorw&auml;rts (nicht blockierende Methode)</td>
  </tr>
  <tr>
    <td>forward(ms)</td>
    <td>f&auml;hrt w&auml;hrend gegebener Zeit (in ms) vorw&auml;rts (blockierende Methode)</td>
  </tr>
 
    <td> left()</td>
    <td>dreht links (nicht blockierende Methode)</td>
  </tr>
  <tr>
    <td> left(ms)</td>
    <td>dreht w&auml;hrend gegebener Zeit (in ms) links (blockierende Methode)</td>
  </tr>
  <tr>
    <td> leftArc(radius)</td>
    <td>f&auml;hrt auf einem Linksbogen mit geg. Radius (nicht- blockierende Methode)</td>
  </tr>
  <tr>
    <td> leftArc(radius, ms)</td>
    <td>f&auml;hrt w&auml;hrend gegebener Zeit (in ms) auf einem Linksbogen (blockierende Methode)</td>
  </tr>
  <tr>
    <td> right()</td>
    <td>dreht rechts (nicht-blockierende Methode)</td>
  </tr>
  <tr>
    <td> right(ms)</td>
    <td>dreht w&auml;hrend gegebener Zeit (in ms)  rechts (blockierende Methode)</td>
  </tr>
  <tr>
    <td> rightArc(radius)</td>
    <td>f&auml;hrt auf einem Rechtsbogen mit geg. Radius (nicht blockierende Methode)</td>
  </tr>
  <tr>
    <td> rightArc(radius, ms)</td>
    <td>f&auml;hrt w&auml;hrend gegebener Zeit (in ms)  auf einem Rechtsbogen (blockierende Methode)</td>
  </tr>
  <tr>
    <td> setSpeed(speed)</td>
    <td>setzt die Geschwindigkeit</td>
  </tr>
   
  <tr>
    <td>stop()</td>
    <td>stoppt das Fahrwerk</td>
  </tr>
  <tr>
    <td>getLeftMotorCount()</td>
    <td>gibt momentanen Z&auml;hlerstand f&uuml;r den linken Motor zur&uuml;ck [nicht f&uuml;r Sim]</td>
  </tr>
  <tr>
    <td>getRightMotorCount()</td>
    <td>gibt momentanen Z&auml;hlerstand f&uuml;r den rechten Motor zur&uuml;ck [nicht f&uuml;r Sim]</td>
  </tr>
  <tr>
    <td>resetLeftMotorCount()</td>
    <td>setzt den Z&auml;hler des linken Motors auf 0 [nicht f&uuml;r Sim]</td>
  </tr>
  <tr>
    <td>resetRightMotorCount()</td>
    <td>setzt den Z&auml;hler des rechten Motors auf 0 [nicht f&uuml;r Sim]</td>
  </tr>
</table>
<h4><br>
TurtleRobot:</h4>
<table width="100%"  border="1" cellpadding="3" cellspacing="0" bordercolor="#CCCCCC">
  <tr> 
    <td width="30%"> TurtleRobot()</td>
    <td width="70%"> erzeugt Roboter mit Fahrwerk </td>
  </tr>
   <tr>
    <td>backward()</td>
    <td>f&auml;hrt r&uuml;ckw&auml;rts (nicht-blockierende Methode)</td>
  </tr>
  <tr> 
    <td>backward(step)</td>
    <td>f&auml;hrt die gegebene Anzahl Schritte  r&uuml;ckw&auml;rts  (blockierende Methode)</td>
  </tr>
   <tr> 
    <td>forward()</td>
    <td>f&auml;hrt vorw&auml;rts (nicht-blockierende Methode)</td>
  </tr>
  <tr> 
    <td>forward(step)</td>
    <td>f&auml;hrt die gegebene Anzahl Schritte vorw&auml;rts  (blockierende Methode)</td>
  </tr>
  <tr> 
    <td>left()</td>
    <td>dreht  links   (nicht-blockierende Methode)</td>
  </tr>
  <tr> 
    <td>left(angle)</td>
    <td>dreht um den gegebenen Winkel links   (blockierende Methode)</td>
  </tr>
  <tr> 
    <td>right()</td>
    <td>dreht rechts   (nicht-blockierende Methode)</td>
  </tr>
   <tr> 
    <td>right(angle)</td>
    <td>dreht um den gegebenen Winkel rechts   (blockierende Methode)</td>
  </tr>
   <tr> 
    <td>setTurtleSpeed(speed)</td>
    <td>setzt  die Geschwindigkeit</td>
  </tr>
 </table>
<h4><br>
Motor:</h4>
<table width="100%"  border="1" cellpadding="3" cellspacing="0" bordercolor="#CCCCCC">
   <tr> 
    <td width="30%">Motor(MotorPort.port)</td>
    <td width="70%">erzeugt einen Motor am Motorport A, B [<em>f&uuml;r EV3, NXT:</em> auch C, <em>f&uuml;r EV3:</em> auch D]</td>
  </tr>
   <tr> 
    <td>backward()</td>
    <td>dreht den Motor r&uuml;ckw&auml;rts</td>
  </tr>
  <tr> 
    <td>forward()</td>
    <td>dreht den Motor vorw&auml;rts</td>
  </tr>
 
  <tr> 
    <td> setSpeed(speed)</td>
    <td>setzt die Geschwindigkeit </td>
  </tr>
  <tr> 
    <td> isMoving()</td>
    <td>gibt True zur&uuml;ck, wenn der Motor in Bewegung ist</td>
  </tr>
  <tr>
    <td>stop()</td>
    <td>stoppt den Motor </td>
  </tr>
  <tr>
    <td>getMotorCount()</td>
    <td>gibt den momentanen Stand des Z&auml;hlers zur&uuml;ck [nicht f&uuml;r Sim]</td>
  </tr>
  <tr>
    <td>resetMotorCount()</td>
    <td>setzt den Z&auml;hler auf 0 [nicht f&uuml;r Sim]</td>
  </tr>
  <tr>
    <td>rotateTo(count)</td>
    <td>setzt Z&auml;hler auf 0, bewegt Motor bis Z&auml;hlerstand count und stoppt (blockierend)  [nicht f&uuml;r Sim]</td>
  </tr>
  <tr>
    <td>rotateTo(count, blocking)</td>
    <td>wie rotateTo(count), aber mit blocking False nicht blockierend [nicht f&uuml;r Sim]</td>
  </tr>
  <tr>
    <td>continueTo(count)</td>
    <td>wie rotateTo(count), aber Z&auml;hler nicht auf 0 gesetzt [nicht f&uuml;r Sim]</td>
  </tr>
  <tr>
    <td>continueTo(count, blocking)</td>
    <td>wie rotateTo(count, blocking), aber Z&auml;hler nicht auf 0 gesetzt [nicht f&uuml;r Sim]</td>
  </tr>
  <tr>
    <td>continueRelativeTo(count)</td>
    <td>wie continueTo(count), aber count ist Inkrement [nicht f&uuml;r Sim]</td>
  </tr>
  <tr> 
    <td>continueRelativeTo(count, blocking)</td>
    <td>wie continueTo(count, blocking), aber count ist Inkrement [nicht f&uuml;r Sim]</td>
  </tr>
</table>
<h4><br>
LightSensor:</h4>
<table width="100%"  border="1" cellpadding="3" cellspacing="0" bordercolor="#CCCCCC">
  <tr> 
    <td width="30%">LightSensor(SensorPort.port)</td>
    <td width="70%">
      <p>erzeugt einen Lichtsensor am SensorPort S1, S2, S3, S4<br>
      <em>Simulationsmodus:</em> Port S1: vorne rechts, S2: vorne links, S3: vorne Mitte, S4: hinten Mitte</p>
    </td>
  </tr>   
  <tr>
    <td>LightSensor(SensorPort.port, bright = onBright, dark = onDark)</td>
    <td>dasselbe mit registrierten Event-Callbacks  onBright(port, value), onDark(port, value) beim &Uuml;berqueren des Triggerlevels</td>
  </tr>
  <tr>
    <td>LightSensor(SensorPort.port, True)</td>
    <td><em>Nur Simulationsmodus: </em>erzeugt einen nach oben gerichteten Lichtsensor am SensorPort S1, S2, S3, S4.    Port S1: vorne rechts, S2: vorne links, S3: hinten rechts, S4: hinten links</td>
  </tr>
  <tr>
    <td>LightSensor(SensorPort.port,  True, bright = onBright, dark = onDark)</td>
    <td>dasselbe mit registrierten Event-Callbacks onBright(port, value), onDark(port, value) beim &Uuml;berqueren des Triggerlevels</td>
  </tr>
  <tr> 
    <td>activate(bool)</td>
    <td>schaltet den LED eines NXT LightSensors ein/aus </td>
  </tr>
  <tr> 
    <td>getValue()</td>
    <td>gibt den Wert des Lichtsensors zur&uuml;ck (Zahl zwischen 0 und 1000) </td>
  </tr>
  <tr> 
    <td>setTriggerLevel(level)</td>
    <td>setzt den Triggerlevel (default: 500)</td>
  </tr>
</table>
<h4><br>
</h4>
<h4>ColorSensor:</h4>
<table width="100%"  border="1" cellpadding="3" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="30%">ColorSensor(SensorPort.port)</td>
    <td width="70%">erzeugt einen Colorsensor am SensorPort S1, S2, S3, S4<br> 
      <em>Simulationsmodus:</em> Port S1: rechts, S2: links, S3: vorne Mitte, S4: hinten Mitte</td>
  </tr>
  <tr>
    <td>getColor()</td>
    <td>gibt die Farbe als Color-Object mit Methoden getRed(), getGreen(), getBlue() zur&uuml;ck, die den RGB-Wert 0..255 liefern</td>
  </tr>
  <tr>
    <td>getColorID()</td>
    <td>gibt eine Farbidentifikationszahl zur&uuml;ck: 
    0: undefiniert, 1: schwarz, 2: blau, 3:gr&uuml;n, 4: gelb, 5: rot, 6: weiss</td>
  </tr>
  <tr>
    <td>getColorStr()</td>
    <td>gibt die Farbe des Unterlagspixel als String zur&uuml;ck (&quot;UNDEFINED&quot;, &quot;BLACK&quot;, &quot;BLUE&quot;, &quot;GREEN&quot;, &quot;YELLOW&quot;, &quot;RED&quot;, &quot;WHITE&quot;)</td>
  </tr>
  <tr>
    <td>getLightValue()</td>
    <td>gibt die Helligkeit (im HSG Modell) des Unterlagepixels  zur&uuml;ck</td>
  </tr>
</table>
<h4><br>
TouchSensor:</h4>
<table width="100%"  border="1" cellpadding="3" cellspacing="0" bordercolor="#CCCCCC">
  <tr> 
    <td width="30%">TouchSensor(SensorPort.port)</td>
    <td width="70%">erzeugt einen Ber&uuml;hrungssensor am SensorPort S1, S2, S3, S4<br> 
      <em>Simulationsmodus:</em> Port S1: rechts, S2: links, S3: vorne Mitte, S4: hinten Mitte</td>
  </tr>  
  <tr>
    <td>TouchSensor(SensorPort.port, pressed = onPressed, released = onReleased)</td>
    <td>dasselbe mit registrierten Event-Callbacks onPressed(port), onReleased(port) </td>
  </tr>
  <tr> 
    <td>isPressed()</td>
    <td>gibt True zur&uuml;ck, falls der Touchsensor gedr&uuml;ckt ist</td>
  </tr>
</table>
<h4><br>
SoundSensor:</h4>
<table width="100%"  border="1" cellpadding="3" cellspacing="0" bordercolor="#CCCCCC">
  <tr> 
    <td width="30%">SoundSensor(SensorPort.port)</td>
    <td width="70%">erzeugt einen Soundsensor am Port S1, S2, S3, S4 (nur 1 Instanz erlaubt)<br>
      <em>Simulationsmodus:</em> Soundkarteneingang. F&uuml;r EV3 den Soundsensor des NXT verwenden: NxtSoundSensor(SensorPort.port)</td>
  </tr> 
  <tr>
    <td>SoundSensor(SensorPort.port, loud = onLoud, quiet = onQuiet)</td>
    <td>dasselbe mit registrierten Event-Callbacks onLoud(port, value), onQuiet(port, value) beim &Uuml;berqueren des Triggerlevels</td>
  </tr>
  <tr> 
    <td>getValue()</td>
    <td>gibt die Lautst&auml;rke zur&uuml;ck (0 -  150)</td>
  </tr>
   <tr> 
    <td>setTriggerLevel(level)</td>
    <td>setzt den Triggerlevel (default: 50)</td>
  </tr>
</table>
<h4><br>
 UltrasonicSensor:</h4>
<table width="100%"  border="1" cellpadding="3" cellspacing="0" bordercolor="#CCCCCC">
   <tr>
     <td width="30%">UltrasonicSensor(SensorPort.port)</td>
     <td width="70%">
       <p>erzeugt einen Ultraschallsensor.<br>
       <em>Simulationsmodus:</em>  S1: vorw&auml;rts; S2: links, S3: r&uuml;ckw&auml;rts</p>
     </td>
   </tr>  
   <tr>
     <td>
       <p>UltrasonicSensor(SensorPort.port,  far = onFar, near = onNear)</p>
     </td>
     <td>dasselbe mit registrierten Event-Callbacks onFar(port, value), onNear(port, value) beim &Uuml;berqueren des Triggerlevels</td>
   </tr>
   <tr>
     <td>getDistance()</td>
     <td>gibt die Entfernung zur&uuml;ck </td>
   </tr>    
   <tr>
     <td>setTriggerLevel(level)</td>
     <td>setzt einen Triggerlevel (default: 10)</td>
   </tr>
   <tr>
     <td>setProximityCircleColor(color)</td>
     <td><em>Simulationsmodus:</em> setzt die Farbe des Suchkreises</td>
  </tr>
   <tr>
     <td>setMeshTriangleColor(color)</td>
     <td><em>Simulationsmodus:</em> setzt die F&uuml;llfarbe der Maschen</td>
  </tr>
   <tr>
     <td>eraseBeamArea()</td>
     <td><em> Simulationsmodus:</em> l&ouml;scht den Strahlbereich</td>
  </tr>
 </table>
<h4>&nbsp;</h4>
<h4>GyroRateSensor (nur EV3):</h4>
<table width="100%"  border="1" cellpadding="3" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="30%">GyroRateSensor(SensorPort.port)</td>
    <td width="70%">
      <p>erzeugt einen GyroRateSensor am SensorPort S1, S2, S3, S4</p>
    </td>
  </tr>
  <tr>
    <td>getValue()</td>
    <td> gibt die Winkelgeschwindigkeit zur&uuml;ck (Grad pro Sekunde, positiv im Gegenuhrzeigersinn)<br>
    </td>
  </tr>
</table>
<h4>&nbsp;</h4>
<h4>GyroAngleSensor (nur EV3):</h4>
<table width="100%"  border="1" cellpadding="3" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="30%">GyroAngleSensor(SensorPort.port)</td>
    <td width="70%">
      <p>erzeugt einen GyroAngleSensor am SensorPort S1, S2, S3, S4</p>
    </td>
  </tr>
  <tr>
    <td>getValue()</td>
    <td> gibt die Orientierung des Sensors bez&uuml;glich seiner Startposition zur&uuml;ck (Grad im Gegenuhrzeigersinn)<br>
    </td>
  </tr>
  <tr>
    <td>reset()</td>
    <td>setzt die Startposition</td>
  </tr>
</table>
<h4><br>
  <br>
  InfraredSensor (nur EV3):</h4>
<table width="100%"  border="1" cellpadding="3" cellspacing="0" bordercolor="#CCCCCC">
   <tr>
     <td width="30%">IRRemoteSensor(SensorPort.port)</td>
     <td width="70%">erzeugt einen Infrarot-Fernsteuerungssensor am Port S1, S2, S3, S4</td>
   </tr>
   <tr>
     <td>getCommand()</td>
     <td>gibt die aktuelle Kommando-ID zur&uuml;ck: 0: nichts, 
         1:oben-links, 2:unten-links, 3:oben-rechts,<br>
4:unten-rechts,5:oben-links+oben-rechts,6:oben-links+unten-rechts,7:unten-links+oben-rechts,<br>
8::unten-links+unten-.rechts,9:Zentrum,10:unten-links+oben-links,11:oben-rechts+unten-rechts.<br>
Der Kanal wird mit dem roten Schiebeschalter gew&auml;hlt.1: oben, 4: unten. Er entspricht der Portnummer, wo der Sensor angeschlossen ist.</td>
   </tr>
   <tr>
     <td>actionPerformed(port, command)</td>
     <td>
       <p>Callback-Funktion, die als benannter Parameter registriert werden kann</p>
       </td>
   </tr>
 </table>
<br>
 <table width="100%"  border="1" cellpadding="3" cellspacing="0" bordercolor="#CCCCCC">

   <tr>
     <td width="30%">IRSeekSensor(SensorPort.port)</td>
     <td width="70%">erzeugt einen Infrarot-Suchensor am Port S1, S2, S3, S4 (aktive IR-Quelle der Fernsteuerung, wenn der Zentrums-Button gedr&uuml;ckt wird)</td>
   </tr>
   <tr>
     <td>v = getValue()</td>
     <td>v.bearing gibt den Richtungswert (-12..12) und v.distance  die Distanz (in cm) zur Quelle zur&uuml;ck. <br>
     Der Kanal wird mit dem roten Schiebeschalter gew&auml;hlt.1: oben, 4: unten. Er entspricht der Portnummer, wo  der Sensor angeschlossen ist.</td>
   </tr>
 </table>
 <br>
 <table width="100%"  border="1" cellpadding="3" cellspacing="0" bordercolor="#CCCCCC">

   <tr>
     <td width="30%">IRDistanceSensor(SensorPort.port)</td>
     <td width="70%">erzeugt einen Infrarot-Distanzsensor am Port S1, S2, S3, S4 (reflektierendes Target)</td>
   </tr>
   <tr>
     <td>getDistance()</td>
     <td>gibt die Distanz zu einem Target zur&uuml;ck (in cm)</td>
   </tr>
 </table>
 <h4><br>
 ArduinoLink (nur EV3):</h4>
 <table width="100%"  border="1" cellpadding="3" cellspacing="0" bordercolor="#CCCCCC">
   <tr>
     <td width="30%">ArduinoLink(SensorPort.port)</td>
     <td width="70%">erzeugt einen I2C-Master zur Verbindung mit dem Arduino  auf Port S1, S2, S3, S4</td>
   </tr>
   <tr>
     <td>
       <p>getReply(request, reply)</p>
     </td>
     <td>sendet den request (Integer 0..255) an den Arduino und liefert die Antwort in der &uuml;bergebenen Liste reply (max.16 Integers 0..255)</td>
   </tr>
   <tr>
     <td>getReplyInt(request)</td>
     <td>sendet den request (Integer 0..255) an den Arduino und liefert eine  Antwort als Integer 0..255</td>
   </tr>
   <tr>
     <td>getReplyString(request)</td>
     <td>
       <p>sendet den request (Integer 0..255) an den Arduino und liefert die Antwort als String (max. 15 ASCII-Zeichen)</p>
     </td>
   </tr>
 </table>
 <h4> <br>
 TemperatureSensor (nur EV3):</h4>
<table width="100%"  border="1" cellpadding="3" cellspacing="0" bordercolor="#CCCCCC">
   <tr>
     <td width="30%">TemperatureSensor(SensorPort.port)</td>
     <td width="70%">erzeugt einen Temperatursensor am SensorPort S1, S2, S3, S4 (Lego NXT Temperature Sensor 9749)<br>
     </td>
   </tr>
   <tr>
     <td>getTemperature()</td>
     <td>gibt die Temperatur im Bereich -55..128 Grad Celsius zur&uuml;ck</td>
   </tr>
 </table>
 <h4><br>
 I2CExpander (nur EV3):</h4>
 <table width="100%"  border="1" cellpadding="3" cellspacing="0" bordercolor="#CCCCCC">
   <tr>
     <td width="30%">I2CExpander(SensorPort.port, deviceType, slaveAddress)</td>
     <td width="70%">erzeugt einen I2C Expander auf Port S1, S2, S3, S4. deviceType = 0: PCF8574, 1: PCF8574A, 2: PCF8591; slaveAddress: 8-bit I2C Adresse</td>
   </tr>
   <tr>
     <td>I2CExpander(SensorPort.port, deviceType, inputMode, slaveAddress)</td>
     <td>dasselbe, aber mit Angabe von inputMode: 0: single ended, 2: three differential, 3: mixed, 4: two differential (gem&auml;ss Datenblatt PCF8591)</td>
   </tr>
   <tr>
     <td>
       <p>writeDigital(out)</p>
     </td>
     <td>setzt den Digital-Eingang/Ausgang  (8 bits) und liefert den aktuellen Wert zur&uuml;ck. F&uuml;r einen digitalen Eingang wird das Portbit auf 1 gesetzt. (Nur f&uuml;r PCF8574/PCF8574A)</td>
   </tr>
   <tr>
     <td>writeAnalog(out)</td>
     <td>setzt den Analog-Ausgang (8 bits). (Nur f&uuml;r PCF8591)</td>
   </tr>
   <tr>
     <td>readAnalog(channel)</td>
     <td>
       <p>liefert den aktuellen Wert von channel 0..3 (0..255 f&uuml;r single ended, -128..127 f&uuml;r differential). (Nur f&uuml;r PCF8591)</p>
     </td>
   </tr>
   <tr>
     <td>readAnalog()</td>
     <td>liefert Liste mit den  aktuellen Werten aller Kan&auml;le. (Nur f&uuml;r PCF8591)</td>
   </tr>
 </table>
 <h4><br>
 <strong><em>Nur Simulationsmodus: </em></strong>RobotContext </h4>
<table width="100%"  border="1" cellpadding="3" cellspacing="0" bordercolor="#CCCCCC">
   <tr>
     <td width="30%">setStartDirection(angle)</td>
     <td width="70%">setzt die Startrichtung des Roboters (0 gegen Osten, positiv im Uhrzeigersinn)</td>
   </tr>
  
   <tr>
     <td>setStartPosition(x, y)</td>
     <td>setzt die Startposition des Roboters (Pixelkoordinaten, Nullpunkt oben links</td>
   </tr>
   <tr>
     <td>showStatusBar(height)</td>
     <td>f&uuml;gt eine Statusbar mit gegebener H&ouml;he unten am Fenster an</td>
   </tr>
   <tr>
     <td>setStatusText(text)</td>
     <td>setzt den Statustext (alter Text wird gel&ouml;scht)</td>
   </tr>
    <tr>
     <td>useBackground(filename)</td>
     <td>f&uuml;gt ein Hintergrundbild f&uuml;r den Lichtsensor ein</td>
   </tr>
   <tr>
     <td>useObstacle(filename, x, y)</td>
     <td>f&uuml;gt ein Hindernis f&uuml;r den Touchsensor an der Position (x, y) ein</td>
   </tr>
   <tr>
     <td>useTarget(filename, mesh, x, y)</td>
     <td>f&uuml;gt ein Target f&uuml;r den Ultraschallsensor an der Position (x, y) ein</td>
   </tr>
   <tr>
     <td>useTorch(power, x, y, z)</td>
     <td>f&uuml;gt ein Spotlicht mit der Leistung power an der Position (x, y, z) ein (mit Maus bewegbar, z: H&ouml;he &uuml;ber Boden). Das Licht wird von nach oben zeigenden Lichtsensoren detektiert.</td>
   </tr>
  <tr>
     <td>useShadow(ulx, ul.y, lrx, lry)</td>
    <td>f&uuml;gt einen rechteckigen Schatten im oberer linker Ecke (ulx, uly) und unterer rechten Ecke (lrx, lry) ein. Dieser deckt Licht von allen Spotlichtern ab.</td>
   </tr>
  </table>
<h4>&nbsp;</h4>
<h4>EV3Copy (nur EV3, direkter Modus):</h4>
<table width="100%"  border="1" cellpadding="3" cellspacing="0" bordercolor="#CCCCCC">
    <tr>
        <td width="30%">EV3Copy.copyFile(ipAddress, sourcePath, targetPath)</td>
        <td width="70%">kopiert die lokale Datei sourcePath auf den targetPath des EV3 mit gegebener IP Adresse (Bsp.: copyFile(&quot;10.0.1.1&quot;, &quot;c:/test.wav&quot;, /home/root/music/song1.wav&quot;)</td>
    </tr>
</table>
<p>&nbsp;</p>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td width="18%">Vollst&auml;ndige JavaDoc </td>
    <td width="82%"><a href="http://www.aplu.ch/classdoc/ev3jliba/index.html">EV3JLibA</a> (Autonomer Modus)</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><a href="http://www.aplu.ch/classdoc/ev3jlib/index.html">EV3JLib</a> (Direkter Modus)</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><a href="http://www.aplu.ch/classdoc/nxtjlib/index.html">NxtJLib</a> (Direkter Modus)</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><a href="http://www.aplu.ch/classdoc/robotsim/index.html">RobotSim</a> (Simulationsmodus)</td>
  </tr>
</table>
<p><a href="http://ch/aplu/docs/index_de.html"><img src="gifs/home.png" alt="home" width="25" height="25"></a></p>
<p>&nbsp;</p>
</body>
</html>

