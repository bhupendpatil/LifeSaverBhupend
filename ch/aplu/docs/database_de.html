<html>
<head>
</head>
<body font face="Arial, Helvetica, sans-serif">
<h2><a href="http://ch/aplu/docs/index_de.html"><img src="gifs/home.png" alt="home" width="25" height="25"></a></h2>
<h2>Dokumentation Datenbanken</h2>
<p>&nbsp;</p>
<h4>Modul import: from sqlite3 import *</h4>
<p>Zugriff auf eine SQLite Datenbank (weitgehend kompatible zu sqlite3 von Python 2.x, 3.x).</p>
<h5>Global:</h5>
<table width="100%"  border="1" cellpadding="3" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="22%" bgcolor="#F0F0F5">Befehl</td>
    <td width="78%" bgcolor="#F0F0F5">Aktion</td>
  </tr>
  <tr>
    <td> connect(database)</td>
    <td>
      <p>stellt eine Verbindung zu einer SQLite-Datenbank-Datei mit gegebenen Dateinamen her und gibt ein Connection-Objekt zur&uuml;ck. Falls die Datenbank-Datei nicht existiert, wie sie erstellt. Die Datenbank wird f&uuml;r den exklusiven Zugriff ge&ouml;ffnet, bis sie mit close() geschlossen wird</p>
    </td>
  </tr>
  <tr>
    <td>connect(database, True)</td>
    <td>dasselbe, aber &ouml;ffnet die Datenbank im Auto-Commit-Modus, d.h. alle Datenbankoperationen werden sofort wirksam</td>
  </tr>
  <tr>
      <td>getDbInfo(database)</td>
      <td>gibt ein Dictionary mit allen Tabellennamen und ihren Feldnamen (Attribute) zur&uuml;ck</td>
  </tr>
</table>
<h4></h4>
<h5>Klasse Connection:</h5>
<table width="100%"  border="1" cellpadding="3" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="22%" bgcolor="#F0F0F5">Methode</td>
    <td width="78%" bgcolor="#F0F0F5">Aktion</td>
  </tr>
  <tr>
    <td> cursor()</td>
    <td>
      <p>erzeugt einen  Datenbank-Cursor und gibt diesen zur&uuml;ck<br>
      </p>
    </td>
  </tr>
  <tr>
    <td>execute(sql)</td>
    <td>f&uuml;hrt  den SQL-Befehl  aus (wird erst bei commit() in der Datenbank wirksam) und gibt den dabei verwendeten Cursor zur&uuml;ck</td>
  </tr>
  <tr>
    <td>commit()</td>
    <td>schreibt einen oder mehrere vorher abgegebene SQL-Befehle  in die Datenbank</td>
  </tr>
  <tr>
    <td>close()</td>
    <td>beendet die Verbindung zur Datenbank. Befehle, die nicht mit commit() abgeschlossen sind, gehen verloren. Wird das Programm durch eine Exception vorher abgebrochen, so bleibt die Verbindung bestehen und TigerJython muss neu gestartet werden, um eine neue Connection aufzubauen</td>
  </tr>
  <tr>
    <td>showTables()</td>
    <td>gibt eine Liste mit den Tabellennamen zur&uuml;ck</td>
  </tr>
  <tr>
    <td>describeTable(table)</td>
    <td>gibt die Information &uuml;ber die Tabellenstruktur als SQL-Create-Befehl zur&uuml;ck</td>
  </tr>
</table>
<h5><strong><br>
    </strong><br>
    Klasse Cursor:</h5>
<table width="100%"  border="1" cellpadding="3" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="22%" bgcolor="#F0F0F5">Methode</td>
    <td width="78%" bgcolor="#F0F0F5">Aktion</td>
  </tr>
  <tr>
    <td> execute(sql)</td>
    <td>
      <p>f&uuml;hrt den SQL-Befehl aus (wird erst bei commit() in der Datenbank wirksam). Bei SELECT wird ein Resultset erzeugt, der mit dem Cursor durchlaufen werden kann<br>
      </p>    </td>
  </tr>
  <tr>
    <td>fetchone()</td>
    <td>liefert den Datensatz zur&uuml;ck, auf den der Cusor zeigt, und stellt den Cursor auf den n&auml;chsten Datensatz. Falls kein Resultset erzeugt wurde oder  der Cursor ausserhalb des Resultset steht, wird None zur&uuml;ckgegeben</td>
  </tr>
  <tr>
    <td>fetchmany(n)</td>
    <td>liefert eine Liste mit den n n&auml;chsten Datens&auml;tze zur&uuml;ck (aufgehend vom Datensatz, auf den der Cursor zeigt) und stellt den Cursor um n vorw&auml;rts. Falls kein Resultset erzeugt wurde, n &lt; 1 ist oder  der Cursor ausserhalb des Resultset steht, wird eine leere Liste zur&uuml;ckgegeben. Falls nicht gen&uuml;gend Datens&auml;tze vorhanden sind, wird der Rest der Datens&auml;tze zur&uuml;ckgegeben</td>
  </tr>
  <tr>
    <td>fetchall()</td>
    <td>liefert eine Liste mit allen Datens&auml;tzen zur&uuml;ck  (aufgehend vom Datensatz, auf den der Cursor zeigt). Falls kein Resultset erzeugt wurde, wird eine leere Liste zur&uuml;ckgegeben</td>
  </tr>
  <tr>
    <td>getColumnNames()</td>
    <td>gibt eine Liste mit den Feldnamen des SELECT-Befehls zur&uuml;ck</td>
  </tr>
  <tr>
    <td>getColumnName(n)</td>
    <td>gibt  den Feldnamen des n-ten Feldes des SELECT-Befehls zur&uuml;ck (n = 1..Anzahl Felder)</td>
  </tr>
  <tr>
    <td>getColumnCount()</td>
    <td>gibt die Anzahl der Felder des SELECT-Befehls zur&uuml;ck</td>
  </tr>
  <tr>
    <td>getMetaData()</td>
    <td>gibt ein MetaData-Objekt zur&uuml;ck (JDBC4ResultSet)</td>
  </tr>
  <tr>
    <td>getBytes(filename)</td>
    <td>gibt einen Bytearray (Typ array.arrray) der Datei filename zur&uuml;ck (absoluter oder relativer Pfad bez&uuml;glich des Verzeichnis, in dem sich tigerjython2.jar befindet)</td>
  </tr>
  <tr>
    <td>updateBlob(table, where, attribute, buffer)</td>
    <td>macht in der gegebenen Tabelle einen Update des BLOB-Feldes mit dem Feldnamen attribute (in allen Datens&auml;tzen, welche die Bedingung where erf&uuml;llten). buffer ist ein Bytearray (Typ array.array), der mit getBytes(filename) von einer Datei geholt werden kann. Beispiel: update(tbl, &quot;id = 1&quot;, &quot;flags&quot;, getBytes(&quot;swissflag.gif&quot;))<br></td>
  </tr>
</table>
<p><a href="http://ch/aplu/docs/index_de.html"></a><a href="http://ch/aplu/docs/index_de.html"></a><strong>Bemerkung:</strong> Wird das Connection-Objekt <em>con</em> in einem <em>with con:</em> -Block verwendet, so wird am Ende des Blocks automatisch <em>con.commit()</em> und <em>con.close()</em> aufgerufen. Auch bei Exceptions wird damit die Datenbank sicher geschlossen. Beispiel:</p>
<p><font face="Courier New, Courier, monospace">from sqlite3 import *
<br>
with connect(&quot;test.db&quot;) as con:<br>
&nbsp;&nbsp;&nbsp;&nbsp;con.execute(&quot;DELETE FROM people&quot;)<br>
</font></p>
<h3><br>
Modul import: from dbapi import *</h3>
<p>Zugriff auf verschiedene Datenbanken: PostgreSQL, SQLite, MySQL, Derby (&uuml;ber JDBC-Treiber)</p>
<table width="100%"  border="1" cellpadding="3" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="22%" bgcolor="#F0F0F5">Befehl</td>
    <td width="78%" bgcolor="#F0F0F5">Aktion</td>
  </tr>
  <tr>
      <td>connect(sqlite:dbname)</td>
      <td>stellt eine Verbindung zu einer SQLite-Datenbank her und gibt ein Connection-Objekt zur&uuml;ck</td>
  </tr>
  <tr>
      <td>connect(derby:dbname)</td>
      <td>stellt eine Verbindung zu einer eingebetteten Derby-Datenbank her und gibt ein Connection-Objekt zur&uuml;ck</td>
  </tr>
  <tr>
    <td> connect(derbyserver:serverURL, dbname, username, password)</td>
    <td>
      <p>stellt eine Verbindung zu einer Derby-Server-Datenbank her und gibt ein Connection-Objekt zur&uuml;ck<br>
      </p>
    </td>
  </tr>
  
  <tr>
    <td>connect(mysql:serverURL, dbname, username, password)</td>
    <td>stellt eine Verbindung zu einer MySQL-Datenbank her und gibt ein Connection-Objekt zur&uuml;ck</td>
  </tr>
  <tr>
    <td>connect(postgre:serverURL, dbname, username, password)</td>
    <td>stellt eine Verbindung zu einer PostgreSQL-Datenbank her und gibt ein Connection-Objekt zur&uuml;ck</td>
  </tr>
</table>
<p>Die JDBC-Treiber k&ouml;nnen von  <a href="http://www.tigerjython.ch/download/tjderby.zip">hier</a> heruntergeladen werden. Sie m&uuml;ssen in das Unterverzeichnis Lib des Verzeichnis von tigerjython2.jar  kopiert werden.<br>
Das Datenbank API entspricht weitgehend den <a href="http://www.python.org/dev/peps/pep-0249">Python Database API Specification v2.0</a>.</p>
<p>&nbsp;</p>
<h3>Modul import: from prettytable import *</h3>
<p>Formatierte Ausgabe von Tabellendaten (cursor ist ein Datenbank-Cursor von SQLite)</p>
<table width="100%"  border="1" cellpadding="3" cellspacing="0" bordercolor="#CCCCCC">
    <tr>
        <td width="22%" bgcolor="#F0F0F5">Befehl</td>
        <td width="78%" bgcolor="#F0F0F5">Aktion</td>
    </tr>
    <tr>
        <td> printTable(cursor)</td>
        <td>
            <p>f&uuml;hrt ein cursor.fetchall() aus und zeigt das Resultat linksb&uuml;ndig formatiert in der Konsole an (ein zweiter Aufruf ergibt ein leeres Resultset)<br>
            </p>
        </td>
    </tr>
    <tr>
        <td>
            <p>strTable(cursor)</p>
        </td>
        <td>dasselbe, aber gibt das formatierte Resultat als String zur&uuml;ck</td>
    </tr>
    <tr>
        <td>printTable(cursor, align = &quot;x&quot;)</td>
        <td>wie oben, aber formatiert alle Spalten f&uuml;r x = &quot;l&quot; linksb&uuml;ndig, &quot;c&quot; zentriert, &quot;r&quot; rechtsb&uuml;ndig (dasselbe f&uuml;r strTable())</td>
    </tr>
    <tr>
        <td>printTable(cursor, align = [&quot;x&quot;, &quot;x&quot;, ...])</td>
        <td>wie oben, aber formatiert Spalten einzeln der Reihe nach f&uuml;r x = &quot;l&quot;, &quot;c&quot;, &quot;r&quot;  (dasselbe f&uuml;r strTable())</td>
    </tr>
    <tr>
        <td>printTable(cursor, align = [&quot;x&quot;, &quot;x&quot;, ...], sortby = fieldname)</td>
        <td>wie oben, aber sortiert die Ausgabe alphabetisch nach dem gegebenen Datenbankfeld (Spalte) (dasselbe f&uuml;r strTable())</td>
    </tr>
    <tr>
        <td>showTable(cursor, params)</td>
        <td>dasselbe wie printTable(), aber die Tabelle wird in einem eigenen Fenster angezeigt</td>
    </tr>
</table>
<p>Das Modul kann auch zur tabularisch formatierten Ausgabe ohne Datenbank-Anbindung verwendet werden. Siehe das Tutorial <a href="http://ptable.readthedocs.io/en/latest/tutorial.html">hier</a>.</p>
<p>&nbsp;</p>
<h3>Modul import: from dbtable import *</h3>
<p>Abstraktion von Datenbank-Tabellen ohne SQL</p>
<p><strong></strong><strong>Klasse DbTable</strong></p>
<table width="100%"  border="1" cellpadding="3" cellspacing="0" bordercolor="#CCCCCC">
  <tr>
    <td width="22%" bgcolor="#F0F0F5">Befehl</td>
    <td width="78%" bgcolor="#F0F0F5">Aktion</td>
  </tr>
  <tr>
    <td> tbl = DbTable(fieldname1, fieldname2,...)</td>
    <td><p>erzeugt ein Tabellenobjekt mit beliebig vielen Feldnamen (als String). Die Feldnamen k&ouml;nnen in ein Tupel gepackt sein<br>
    </p></td>
  </tr>
  <tr>
      <td>tbl = DbTable(anotherTable)</td>
      <td>erzeugt einen (tiefen) Klone des Tabellenobjekts</td>
  </tr>
  <tr>
    <td>tbl = DbTable()</td>
    <td>erzeugt eine leere Tabelle, die f&uuml;r restore(), restoreFromTJ() oder importFromCSV() verwendet werden kann</td>
  </tr>
  <tr>
    <td><p>tbl.insert(value1, value2,...)</p></td>
    <td>f&uuml;gt eine Zeile mit den gegebenen Werten in die Tabelle. Die Werte k&ouml;nnen in ein Tupel gepackt sein. Erlaubte Datentypen: str, int, float, BLOB (bin&auml;r). Es m&uuml;ssen die Werte aller Felder angegeben werden. Aus der zuerst eingegenen Zeile wird der Datentyp der Felder bestimmt. Bin&auml;re Felderwerte sind Bytearrays (R&uuml;ckgabewert von getBytes(filename))</td>
  </tr>
  <tr>
      <td>tbl.insertMany(liste)</td>
      <td>f&uuml;gt mehrere Zeilen, die in liste (oder tuple) enthalten sind (beispielsweise von einer select() R&uuml;ckgabe). Aus der zuerst eingegenen Zeile wird der Datentyp der Felder bestimmt (int, float oder str)</td>
  </tr>
  <tr>
      <td>for row in tbl:<br>
              <font size="-1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do_something_ with row.fieldname</font></td>
      <td>Durchlaufen aller Zeilen und Verwenden der Feldwerte</td>
  </tr>
  <tr>
    <td>tbl.select(fieldname1, fieldname2, ..., pattern)</td>
    <td>gibt ein Tupel aller Zeilen mit den angegebenen Feldern  zur&uuml;ck. Wird mit sort() ein Sortierattribut angegeben, so  werden die Zeilen in der Sortierreihenfolge zur&uuml;ckgegeben.   pattern ist eine Sequenz mit Gleichheitsbedingungen attribute = wert. Falls ein Attribut fehlt, erf&uuml;llen alle Werte die Bedingung. Beispiel: select(&quot;name&quot;, &quot;vorname&quot;, &quot;alter&quot;, name = &quot;Meyer&quot;, vorname = &quot;Hans&quot;) gibt die Felder &quot;name&quot;, &quot;vorname&quot; und &quot;alter&quot; aller &quot;Meyer Hans&quot; zur&uuml;ck. Die Werte haben den Datentyp str, int oder float</td>
  </tr>
  <tr>
      <td>tbl.sort(fieldname)</td>
      <td>definiert einen Feldnamen (String) als Sortierattribut. Tabellenansichten und select() werden nachher in aufsteigender Reihenfolge dieses Attributs ausgegeben. Ohne Angabe eines Sortierattributs, ist die Reihenfolge der Zeilen undefiniert (aber normalerweise in der Reihenfolge der mit insert() eingef&uuml;gten Zeilen)</td>
  </tr>
  <tr>
      <td>tbl.sort(fieldname, False)</td>
      <td>dasselbe, aber in absteigender Reihenfolge</td>
  </tr>
  <tr>
    <td>tbl.getAttributes()</td>
    <td>gibt ein Tupel mit den Feldnamen (Attributen) zur&uuml;ck</td>
  </tr>
  <tr>
    <td>tbl.view()</td>
    <td>zeigt die Tabellenwerte formatiert in der Konsole (sortiert gem&auml;ss einem Sortierattribut)</td>
  </tr>
  <tr>
      <td>tbl.view(fieldname1, fieldname2, ..., pattern)</td>
      <td>dasselbe, aber es werden nur die angegebenen Felder von Zeilen angezeigt, welche die Gleichheitsbedingungen erf&uuml;llen (wie select())</td>
  </tr>
  <tr>
    <td>tbl.getView()</td>
    <td>dasselbe, aber R&uuml;ckgabe als formatieren String</td>
  </tr>
  <tr>
      <td>tbl.getView(fieldname1, fieldname2, ..., pattern)</td>
      <td>dasselbe, aber es werden nur die angegebenen Felder von Zeilen zur&uuml;ck gegeben, welche die Gleichheitsbedingungen erf&uuml;llen (wie select())</td>
  </tr>
  <tr>
    <td>print tbl</td>
    <td>dasselbe wie tbl.view()</td>
  </tr>
  <tr>
      <td>len(tbl)</td>
      <td>gibt die Anzahl Tabellenzeilen zur&uuml;ck</td>
  </tr>
  <tr>
    <td>tbl.delete(pattern)</td>
    <td>l&ouml;scht alle Zeilen, welche die Gleichheitsbedingungen in pattern erf&uuml;llen (wie bei select()). Beispiel: delete(name = &quot;Meyer&quot;, vorname = &quot;Hans&quot; l&ouml;scht alle Zeilen mit Meyer Hans.</td>
  </tr>
  <tr>
    <td>tbl.update(pattern)(fieldname1 = value1, fieldname2 = value2,...)</td>
    <td>ersetzt bestimmte Tabellenwerte. Es werden dazu zwei Parameterklammern verwendet. In der ersten Klammer werden mit pattern wie in select() die Zeilen ausgew&auml;hlt. In der zweiten Parameterklammer werden die neuen Feldwerte der ausgew&auml;hlten Zeilen angegeben. Beispiel: update(name = &quot;Meyer&quot;, vorname = &quot;Hans&quot;)(wohnort = &quot;Basel&quot;) setzt den Wohnort aller &quot;Meyer Hans&quot; auf &quot;Basel&quot;. Ist die erste Parameterklammer leer, so werden alle Zeilen modifiziert</td>
  </tr>
  <tr>
      <td>tbl.join(otherTable, left, right)</td>
      <td>gibt eine Tabelle zur&uuml;ck, die einer Tabellenverbindung (join) der vorhandenen Tabelle mit otherTable entspricht, wobei die attribute left und right &uuml;bereinstimmen m&uuml;ssen. Die Vergleichsattribute werden nicht &uuml;bernommen. Beispiel: person.join(sport, person.id = sport.id)</td>
  </tr>
  <tr>
      <td>tbl.join(otherTable, left, right, True)</td>
      <td>dasselbe, aber es werden auch die Vergleichsattribute &uuml;bernommen (diese m&uuml;ssen unterschiedliche Namen haben)</td>
  </tr>
  <tr>
    <td>tbl.join(otherTable)</td>
    <td>dasselbe, aber es werden alle Zeilen beider Tabellen miteinander verbunden (Kreuzprodukt)</td>
  </tr>
  <tr>
    <td> tbl.saveTable(databaseName, tableName)</td>
    <td>
        <p>speichert die Werte aus table in einer SQL-Datenbanktabelle einer SQLite-Datenbank mit gegebenen Dateinamen unter dem gegebenen SQLite-Datenbank-Tabellennamen. Falls die Datenbank nicht existiert, wird sie erzeugt. Eine bestehende Tabelle mit gleichem Namen wir gel&ouml;scht. Die Feldnamen (Attribute) und Datentypen werden &uuml;bernommen. Wird tableName nicht angegeben, so wird der Variablenname als SQLite-Tabellenname verwendet</p>    </td>
  </tr>
  <tr>
    <td>tbl.restoreTable(databaseName, tableName)</td>
    <td>holt die mit saveTable() in der SQLite-Datenbank gespeicherten Werte aus der gegebenen SQLite-Datenbank-Tabelle und gibt ein DbTable-Objekt  mit den wiederhergestellten Feldnamen (Attributen) zur&uuml;ck. Wird tableName nicht angegeben, so wird der Variablenname als SQLite-Tabellenname verwendet.</td>
  </tr>
  <tr>
    <td>tbl.restoreFromTJ(databaseName, tableName)</td>
    <td>dasselbe, aber die Datenbank wird zuerst aus der  TigerJython-Distribution (tigerjython2.jar) geholt und in das Verzeichnis des Programms kopiert</td>
  </tr>
  <tr>
    <td>tbl.importFromCSV(filename, delimiter)</td>
    <td>
        <p>importiert den Inhalt einer CSV-Datei (Textdatei). Die Felder m&uuml;ssen durch das Trennzeichen delimiter getrennt sein. Jede Zeile muss genau die gleiche Anzahl Felder haben. Aus der ersten Zeile wird der Typ der Felder (int, float, str) ermittelt</p>    </td>
  </tr>
  <tr>
    <td>tbl.exportToCSV(filename, delimiter, fieldname1, fieldname2, ..., pattern)</td>
    <td>exportiert die Tabellendaten in eine CSV-Datei, wobei die Felder  mit dem angegebenen Trennzeichen getrennt sind. Es werden nur die angegebenen Felder &uuml;bernommen.    pattern ist eine Sequenz mit Gleichheitsbedingungen attribute = wert. Fehlen fieldname und pattern, so wird die ganze Tabelle &uuml;bernommen (wie bei select())</td>
  </tr>
  <tr>
    <td>getBytes(filename)</td>
    <td>gibt einen Bytearray (Typ array.arrray) der Datei filename zur&uuml;ck (absoluter oder relativer Pfad bez&uuml;glich des Verzeichnis, in dem sich tigerjython2.jar befindet)</td>
  </tr>
  <tr>
    <td>storeBytes(buffer, filename)</td>
    <td>schreibt den Bytearray (type array.array) in die Datei filename (ersetzt vorhandene Datei)</td>
  </tr>
  <tr>
      <td>showDbInfo(database)</td>
      <td>schreibt von einer Datenbank alle Tabellennamen und ihre Feldnamen aus</td>
  </tr>
  <tr>
      <td>showDbInfoTJ(database)</td>
      <td>schreibt von einer Datenbank in der TigerJython-Distribution alle Tabellennamen und ihre Feldnamen (Attribute) aus</td>
  </tr>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h4><a href="http://ch/aplu/docs/index_de.html"><img src="gifs/home.png" alt="home" width="25" height="25"></a></h4>
<p>&nbsp;</p>
</body>
</html>

